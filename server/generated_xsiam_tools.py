"""
Auto-generated MCP tools for XSIAM.
Generated from OpenAPI specification: xsiam.json

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by codegen/generator.py
"""

from typing import Any, Dict, List

import httpx
from mcp.server import Server
from mcp import types

# This will be set by the server initialization
server: Server = None  # type: ignore


def set_server(s: Server) -> None:
    """Set the server instance for tool registration."""
    global server
    server = s


@server.call_tool()
async def post_start_xql_query(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Execute an XQL query.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/start_xql_query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_start_xql_query
post_start_xql_query_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_query_results(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve results of an executed XQL query API. 

Note: This endpoint only works on XQL queries initiated by `/public_api/v1/xql/start_xql_query/`.

Maximum result set size is 1000. The API does not support pagination, therefore, you can set values to determine the result size limitation and how to wait for the results. To view response with greater than 1000 results you must call **Get XQL query results Stream**.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/get_query_results"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_query_results
post_get_query_results_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_quota(

) -> List[types.TextContent]:
    """
    Retrieve the amount of query quota available and used. 

Note: This endpoint only works on XQL queries initiated by `/public_api/v1/xql/start_xql_query/`.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/get_quota"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_quota
post_get_quota_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def post_get_query_results_stream(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
    accept__encoding: str | None = None,
) -> List[types.TextContent]:
    """
    Retrieve XQL query results with more than 1000 results. 

Note: This endpoint only works on XQL queries initiated by `/public_api/v1/xql/start_xql_query/`.

Response is returned as chunked (Transfer-Encoding: chunked). To retrieve a compressed gzipped response (Content-Encoding: gzip), in your header add Accept-Encoding: gzip.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if accept__encoding is not None:
        headers["Accept-Encoding"] = accept__encoding
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/get_query_results_stream"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_query_results_stream
post_get_query_results_stream_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "accept__encoding": {"type": "str", "description": "For retrieving a compressed gzipped response"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_incidents(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of incidents filtered by a list of incident IDs, modification time, or creation time.  This includes all incident types and severities, including correlation-generated incidents.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

Note: You can send a request to retrieve either **all** or **filtered** results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/incidents/get_incidents"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_incidents
post_get_incidents_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_alerts_get_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of all or filtered alerts.  The alerts listed are what remains after alert exclusions are applied by Cortex XSIAM.

- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of alerts from the start of the result set.
The response indicates whether an PAN NGFW type alert contains a PCAP triggering packet. Use the Retrieve PCAP Packet API to retrieve a list of alert IDs and their associated PCAP data.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/get_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_alerts_get_alerts
post_public_api_v1_alerts_get_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v2_alerts_get_alerts_multi_events(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a list of alerts with multiple events.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is 100.
- Offset is the zero-based number of alerts from the start of the result set.

Cortex XDR displays in the API response whether a PAN NGFW type alert contains a PCAP triggering packet. Use the **Retrieve PCAP Packet** API to retrieve a list of alert IDs and their associated PCAP data.

Note: You can send a request to retrieve either all or filtered results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v2/alerts/get_alerts_multi_events"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v2_alerts_get_alerts_multi_events
post_public_api_v2_alerts_get_alerts_multi_events_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_get_alerts_multi_events(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    **Note: ** This endpoint is legacy. Use the [Get Alerts Multi-Events v2](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/guxcmlw6h3y8v-get-alerts-multi-events-v2) endpoint.

Get a list of alerts with multiple events.
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of alerts from the start of the result set.
Cortex XDR displays in the APIs response whether an PAN NGFW type alert contains a PCAP triggering packet. Use the Retrieve PCAP Packet API to retrieve a list of alert IDs and their associated PCAP data.

Note: You can send a request to retrieve either all or filtered results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/get_alerts_multi_events"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_alerts_multi_events
post_get_alerts_multi_events_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_update_incident(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Update one or more fields of a specific incident. Missing fields are ignored.
**Note**:
- `assigned_user_mail` field is validated by Cortex XSIAM to confirm the provided assignee email address belongs to a user that exists in the same Cortex XSIAM tenant.
- To unassign an incident pass `none` or `"assigned_user_mail": ""`.
- To remove a manually set severity pass `none` or `"manual_severity": ""`.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/incidents/update_incident"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_update_incident
post_update_incident_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_update_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Update one or more alerts. You can update up to 100 alerts per request. Missing fields are ignored.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/update_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_update_alerts
post_update_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "(Required) A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_insert_cef_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Upload alerts in CEF format from external alert sources. After you map CEF alert fields to Cortex XDR fields, Cortex XDR displays the alerts in related incidents and views.
You can send 600 alerts per minute.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/insert_cef_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_insert_cef_alerts
post_insert_cef_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_insert_parsed_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Upload alerts from external alert sources in Cortex XSIAM format. Cortex XSIAM displays alerts that are parsed successfully in related incidents and views.
You can send 600 alerts per minute. Each request can contain a maximum of 60 alerts.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/insert_parsed_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_insert_parsed_alerts
post_insert_parsed_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_alerts_pcap(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Retrieve a list of alert IDs and the associated PCAP triggering packets of PAN NGFW type alerts returned when running the **Get Alerts** and **Get Extra Incident Data** APIs. Maximum result set size is 100.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/get_alerts_pcap"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_alerts_pcap
post_get_alerts_pcap_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_create_alert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Create a custom alert.

In addition to the mandatory fields (`vendor`, `product`, `severity`, `category`), any field that appears in the alert table can be used. In order to use a field from the alert table, use its lower camel case representation. For example: `Container ID` -> `container_id`. If the field in the alert table contains a hyphen, replace it with underscore, for example: `App - ID` -> `app_id`.

The following fields are recommended for creating an alert:
	- `remote_ip`
	- `remote_host`
	- `host_name`
	- `group_id`
	- `initiated_by`
	- `initiator_sha256`
	- `target_process_sha256`
	- `cgo_sha256`
	- `file_sha256`
	- `os_parent_cmd`
	- `os_parent_user_name`

By using multiple calls of `create_alert`, you can send up to 600 alerts per minute.

Required role: **App Service Account**

Required licenses: **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/alerts/create_alert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_create_alert
post_create_alert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_replace_hosts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured hosts listed in your environment.

Note: Running this API will delete all existing host names.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/featured_fields/replace_hosts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_replace_hosts
post_replace_hosts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_replace_users(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured users listed in your environment.

Note: Running this API will delete all existing user names.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/featured_fields/replace_users"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_replace_users
post_replace_users_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_replace_ip_addresses(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured IP addresses listed in your environment.

Note: Running this API will delete all existing IP addresses.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/featured_fields/replace_ip_addresses"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_replace_ip_addresses
post_replace_ip_addresses_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_replace_ad_groups(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured active directory groups and organizational units listed in your environment.

Note: Running this API will delete all existing active directory groups.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/featured_fields/replace_ad_groups"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_replace_ad_groups
post_replace_ad_groups_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_versions(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Get a list of all the agent versions to use for creating a distribution list.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/distributions/get_versions"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_versions
post_get_versions_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_get_endpoints(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Gets a list of all of your endpoints. The response is concatenated using AND condition (OR is not supported).

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/get_endpoints"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_endpoints
post_get_endpoints_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_get_policy(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the policy name for a specific endpoint.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/get_policy"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_policy
post_get_policy_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete selected endpoints in the Cortex XDR app. You can delete up to 1000 endpoints.

Note: Endpoints are deleted from the Cortex XDR app web interface, however they still exist in the database.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 1000.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_delete
post_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_create(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Create an installation package. This is an async call that returns the distribution ID; it does not mean that the creation succeeded. To confirm the package has been created, check the status of the distribution by running the **Get Distribution Status** API.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/distributions/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_create
post_create_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_violations(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Gets a list of device control violations filtered by selected fields. You can retrieve up to 100 violations.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/device_control/get_violations"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_violations
post_get_violations_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "An empty object returns all results."},
    },
}

@server.call_tool()
async def post_get_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Check the status of the installation package.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/distributions/get_status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_status
post_get_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_get_dist_url(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the distribution URL for downloading the installation package.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/distributions/get_dist_url"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_dist_url
post_get_dist_url_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_update_agent_name(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Set or modify an Alias field for your endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/update_agent_name"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_update_agent_name
post_update_agent_name_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_assign(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Assign one or more tags to one or more endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/tags/agents/assign"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_assign
post_assign_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_remove(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Remove one or more tags from one or more endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/tags/agents/remove"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_remove
post_remove_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the following API request fields."},
    },
}

@server.call_tool()
async def post_restore(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Restore a quarantined file on a requested endpoints.
When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/restore"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_restore
post_restore_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_file_retrieval_details(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    View the API required to call in order to download the file retrieved by the **Retrieve File** API request according to the action ID.

The response contains a file hash you need to download and then unzip to view:
1. Download the file.

<!--
title: "Request Example"
-->
``` curl
curl -XPOST "https://api-{fqdn}/public_api/v1/download/<api_value>" 
-H "x-xdr-auth-id:{API_KEY_ID}"  
-H "Authorization:{API_KEY}" 
-H 'Content-Type:application/json' 
--output /tmp/file.zip
```
2. Unzip the file: `unzip /tmp/file.zip`

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/actions/file_retrieval_details"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_file_retrieval_details
post_file_retrieval_details_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_allowlist(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Add files which do not exist in the allow or block lists to an allow list.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/hash_exceptions/allowlist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_allowlist
post_allowlist_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the quarantine status for specified files.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/quarantine/status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_status
post_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_quarantine(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Quarantine file on selected endpoints. You can select up to 1000 endpoints.

Note: A success response means that the request reached the defined endpoints, however if the file was not found there, no quarantine action will take place. To ensure if the file has been quarantined, check the Cortex XDR Action Center.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 1000.
- Offset is the zero-based number of incidents from the start of the result set.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/quarantine"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_quarantine
post_quarantine_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_blocklist(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Add files which do not exist in the allow or block lists to a block list. You can view the block list in the UI at **Incident Response** > **Action Center** > **Block List**.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/hash_exceptions/blocklist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_blocklist
post_blocklist_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_unisolate(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Reverse the isolation of one or more endpoints in single request.

Note: You can only send a request with either `endpoint_id` to unisolate one endpoint or with filters to unisolate more than one endpoint. An error is raised if you try to use both `endpoint_id` and the filters.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/unisolate"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_unisolate
post_unisolate_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_abort_scan(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Cancel the scan of selected endpoints. A scan can only be aborted if the selected endpoints are in **Pending** or in **Progress** status.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Offset is the zero-based number of endpoints from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/abort_scan"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_abort_scan
post_abort_scan_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_scan(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Run a scan on selected endpoints.
- Response is concatenated using AND condition (OR is not supported).
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/scan"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_scan
post_scan_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_get_action_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the status of the requested actions according to the action ID.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/actions/get_action_status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_action_status
post_get_action_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_run_snippet_code_script(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Initiate a new endpoint script execution action using provided snippet code. Cortex XDR supports sending your request in Base64.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/run_snippet_code_script"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_run_snippet_code_script
post_run_snippet_code_script_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_run_script(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Initiate a new endpoint script execution action using a script from the script library. The script can be run on up to 1000 endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/run_script"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_run_script
post_run_script_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_get_script_metadata(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the full definitions of a specific script in the scripts library.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get_script_metadata"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_script_metadata
post_get_script_metadata_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_get_script_execution_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the status of a script execution action.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get_script_execution_status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_script_execution_status
post_get_script_execution_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_get_scripts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a list of scripts available in the scripts library.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get_scripts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_scripts
post_get_scripts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_get_script_execution_results(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the results of a script execution action.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get_script_execution_results"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_script_execution_results
post_get_script_execution_results_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_get_script_execution_results_files(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the files retrieved from a specific endpoint during a script execution.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get_script_execution_results_files"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_script_execution_results_files
post_get_script_execution_results_files_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_get_script_code(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the code of a specific script in the script library.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get_script_code"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_get_script_code
post_get_script_code_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_insert_csv(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: str,
    validate: bool | None = None,
) -> List[types.TextContent]:
    """
    Upload IOCs in CSV format that you retrieved from external threat intelligence sources. 

Note: Cortex XDR does not scan historic data, but rather only new incoming data.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data
    if validate is not None:
        body["validate"] = validate

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/indicators/insert_csv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_insert_csv
post_insert_csv_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "str", "description": "The body of this request contains a JSON object with a single field: `request_data`. This field is required. Its value is as string containing two or more comma-separated lines. The first line must contain the CSV header. All subsequent lines must represent IOC data. Each line must include at a minimum the required CSV fields, which are identified below. To help you validate the upload, you can send a separate validate field to view an array of errors with an unsuccessful call. | Field | Description | | ----------- | ----------- | | indicator | (Required) String that identifies the indicator you want to insert into Cortex XDR. | | type | (Required) Keyword identifying the type of indicator. Valid values are: `HASH`, `IP`, `PATH`, `DOMAIN_NAME`, or `FILENAME` | | severity | (Required) Keyword identifying the indicator's severity. Valid values are: `INFO`, `LOW`, `MEDIUM`, `HIGH`, or `CRITICAL` | | expiration_date | Integer representing the indicator's expiration timestamp. This is a Unix epoch timestamp value, in milliseconds. If this indicator has no expiration, use `Never`. If this value is NULL, the indicator receives the indicator's type value with the default expiration date. Valid values are: 7 days, 30 days, 90 days, or 180 days | | comment | Comment string. | | reputation | Keyword representing the indicator's reputation. Valid values are: `GOOD`, `BAD`, `SUSPICIOUS`, or `UNKNOWN` | | reliability | Character representing the indicator's reliability rating. Valid values are A-F. A is the most reliable, F is the least. | | class | String representing the indicator class (for example, \"Malware\") | | vendor.name | String representing the name of the vendor who reported this indicator. | | vendor.reputation | Keyword representing the vendor's reputation. Valid values are: `GOOD`, `BAD`, `SUSPICIOUS`, or `UNKNOWN` | | vendor.reliability | Character representing the vendor's reliability rating. Valid values are A-F. A is the most reliable, F is the least. |"},
        "validate": {"type": "bool", "description": "Indicates whether to return an array of errors in the case of an unsuccessful update indicator API request."},
    },
}

@server.call_tool()
async def post_insert_jsons(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
    validate: bool | None = None,
) -> List[types.TextContent]:
    """
    Upload IOCs as JSON objects that you retrieved from external threat intelligence sources.

Note: Cortex XSIAM does not scan historic data, rather only new incoming data.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data
    if validate is not None:
        body["validate"] = validate

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/indicators/insert_jsons"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_insert_jsons
post_insert_jsons_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
        "validate": {"type": "bool", "description": "Whether to return an array of errors in the case of an unsuccessful update indicator API request."},
    },
}

@server.call_tool()
async def post_management_logs(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get audit management logs.
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/audits/management_logs"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_management_logs
post_management_logs_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def get_healthcheck(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Perform a health check of your Cortex XSIAM environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/healthcheck"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_healthcheck
get_healthcheck_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_public_api_v1_system_get_tenant_info(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get your tenant license information.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/system/get_tenant_info"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_system_get_tenant_info
post_public_api_v1_system_get_tenant_info_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_incidents_get_incident_extra_data(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get extra data fields of a specific incident including alerts and key artifacts.

- Cortex XDR displays in the APIs response whether a PAN NGFW type alert contains a PCAP triggering packet.
Use the **Retrieve PCAP Packet** API to retrieve a list of alert IDs and their associated PCAP data.

Note: The API includes a limit rate of 10 API requests per minute.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/incidents/get_incident_extra_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_incidents_get_incident_extra_data
post_public_api_v1_incidents_get_incident_extra_data_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_rbac_get_users(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Retrieve a list of the current users in your environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/rbac/get_users"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_rbac_get_users
post_public_api_v1_rbac_get_users_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_public_api_v1_rbac_get_roles(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Retrieve information about one or more roles created in your environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/rbac/get_roles"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_rbac_get_roles
post_public_api_v1_rbac_get_roles_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_rbac_get_user_group(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve a list of the current user emails associated with one or more user groups in your environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/rbac/get_user_group"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_rbac_get_user_group
post_public_api_v1_rbac_get_user_group_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_rbac_set_user_role(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add or remove one or more users from a role.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/rbac/set_user_role"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_rbac_set_user_role
post_public_api_v1_rbac_set_user_role_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_endpoints_get_endpoint(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Gets a list of filtered endpoints.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is 100.
- Offset is the zero-based number of endpoints from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/get_endpoint"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_endpoints_get_endpoint
post_public_api_v1_endpoints_get_endpoint_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_get_risk_score(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the risk score of a specific user or endpoint in your environment, along with the reason for the score.

Required license: **Cortex XSIAM Premium** or **Identity Threat Module**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/get_risk_score"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_get_risk_score
post_public_api_v1_get_risk_score_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_get_risky_users(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Retrieve a list of users with the highest risk score in your environment along with the reason affecting each score.

Required license: **Cortex XSIAM Premium** or **Identity Threat Module**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/get_risky_users"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_get_risky_users
post_public_api_v1_get_risky_users_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_public_api_v1_get_risky_hosts(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Retrieve a list of endpoints with the highest risk score in your environment along with the reason for each score.

Required license: **Cortex XSIAM Premium** or **Identity Threat Module**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/get_risky_hosts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_get_risky_hosts
post_public_api_v1_get_risky_hosts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_public_api_v1_endpoints_file_retrieval(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve files from selected endpoints. You can retrieve up to 20 files, from no more than 10 endpoints.
- Response is concatenated using AND condition (OR is not supported).
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/file_retrieval"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_endpoints_file_retrieval
post_public_api_v1_endpoints_file_retrieval_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_endpoints_isolate(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Isolate one or more endpoints in a single request. Request is limited to 1000 endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/endpoints/isolate"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_endpoints_isolate
post_public_api_v1_endpoints_isolate_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_audits_agents_reports(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get agent event reports.
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/audits/agents_reports"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_audits_agents_reports
post_public_api_v1_audits_agents_reports_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_service(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get service details according to the service ID. You can send up to 20 IDs.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise**, **Cortex XSIAM Enterprise Plus** or **Cortex XSIAM Premium**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_service"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_service
post_public_api_v1_assets_get_external_service_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_services(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of all your external services.

The maximum result limit is 500.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise**, **Cortex XSIAM Enterprise Plus** or **Cortex XSIAM Premium**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_services"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_services
post_public_api_v1_assets_get_external_services_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "api-key"},
        "x_xdr_auth_id": {"type": "str", "description": "api-key-id"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_assets_internet_exposure(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of all your Internet exposure filtered by business units, externally detected providers, externally inferred CVEs, mac addresses, names, IP addresses, whether it has an XDR agent, whether it has active external services, and type.

The maximum result limit is 500 assets.

Note: You can send a request to retrieve either all or filtered results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_assets_internet_exposure"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_assets_internet_exposure
post_public_api_v1_assets_get_assets_internet_exposure_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_asset_internet_exposure(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get Internet exposure asset details according to the asset ID. You can send up to 20 IDs.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_asset_internet_exposure"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_asset_internet_exposure
post_public_api_v1_assets_get_asset_internet_exposure_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_ip_address_ranges(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of all your Internet exposure filtered by business units and organization handles.

The maximum result limit is 1000 ranges.

Note: You can send a request to retrieve either **all** or **filtered** results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_ip_address_ranges"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_ip_address_ranges
post_public_api_v1_assets_get_external_ip_address_ranges_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_ip_address_range(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get external IP address range details according to the range IDs. You can send up to 100 IDs.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_ip_address_range"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_ip_address_range
post_public_api_v1_assets_get_external_ip_address_range_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_triage_endpoint(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Initiate forensics triage for the specified agents.
- Maximum of 10 concurrent triage actions at a time.
- Specified agents must have Forensics License enabled.
- Specified agents must be the same OS, Windows or macOS, but not a mixture of both.
- Specified configuration must have type "Online = True".

Required license: **Cortex XSIAM Premium** or  
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/triage_endpoint"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_triage_endpoint
post_public_api_v1_triage_endpoint_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_vulnerability_tests(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of vulnerability tests. Results include details about each test, including the number of services confirmed vulnerable.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_vulnerability_tests"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_vulnerability_tests
post_public_api_v1_assets_get_vulnerability_tests_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_bulk_update_vulnerability_tests(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Enable or disable vulnerability tests.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/bulk_update_vulnerability_tests"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_bulk_update_vulnerability_tests
post_public_api_v1_assets_bulk_update_vulnerability_tests_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_dataset_define_dataset(
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Define an XQL user dataset based on an existing BigQuery table created by the user.

**Note:** BigQuery table must be an existing table under public_access_user.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.

These APIs are only applicable from within the XSIAM Notebook environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/dataset/define_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_dataset_define_dataset
post_public_api_v1_dataset_define_dataset_schema = {
    "type": "object",
    "properties": {
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_dataset_get_created_datasets(

) -> List[types.TextContent]:
    """
    Retrieve a list of all XQL user datasets created using the Cortex SDK.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.

These APIs are only applicable from within the XSIAM Notebook environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/dataset/get_created_datasets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_dataset_get_created_datasets
post_public_api_v1_dataset_get_created_datasets_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def post_public_api_v1_dataset_delete_dataset(
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete an XQL user dataset that was created by the Cortex SDK.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.

These APIs are only applicable from within the XSIAM Notebook environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/dataset/delete_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_dataset_delete_dataset
post_public_api_v1_dataset_delete_dataset_schema = {
    "type": "object",
    "properties": {
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_xql_add_dataset(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add a dataset of type `lookup` with the specified name and schema.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/add_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_xql_add_dataset
post_public_api_v1_xql_add_dataset_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_xql_delete_dataset(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete a dataset with the specified name. The following dataset types can be deleted: Lookup, Raw, User, Snapshot, and Correlation. You can only delete a dataset with dependencies by setting `force` to TRUE.

**Note:** The System dataset and other protected datasets cannot be deleted.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v2/xql/delete_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_xql_delete_dataset
post_public_api_v1_xql_delete_dataset_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_xql_get_datasets(
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Retrieve a list of all the datasets and their properties.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/get_datasets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_xql_get_datasets
post_public_api_v1_xql_get_datasets_schema = {
    "type": "object",
    "properties": {
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_xql_lookups_add_data(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add or update data in a lookup dataset.

When updating data, any field not specified in the `data` field, but specified on at least one of the rows, will be set to `None`.

The `/public_api/xql/lookups/add_data/`  endpoint does not support concurrent edits. Sending concurrent calls to this endpoint can cause data to be unintentionally overwritten or deleted. To allow sufficient time for each API call to complete its operation before initiating another one, assume that 1000 entries can be added per API every 10 seconds.

**Note: ** 

- The maximum size of a lookup dataset is 50 MB. Attemping to exceed this limit will fail.
- Requests time out after three minutes.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/lookups/add_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_xql_lookups_add_data
post_public_api_v1_xql_lookups_add_data_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_xql_lookups_remove_data(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Remove data from a dataset based on the specified parameters. If any one of the filter sets are not found, the API does not delete any data.

The `/public_api/xql/lookups/remove_data/`  endpoint does not support concurrent edits. Sending concurrent calls to this endpoint can cause data to be unintentionally overwritten or deleted. To allow sufficient time for each API call to complete its operation before initiating another one, assume that 1000 entries can be added per API every 10 seconds.

**Note:** 
- All lookup entries matching any of the filter blocks are deleted. To match a filter block, a lookup entry must match all the specified fields as if there were an `AND` operator between them. 
- Requests time out after three minutes.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/lookups/remove_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_xql_lookups_remove_data
post_public_api_v1_xql_lookups_remove_data_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_xql_lookups_get_data(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get data from a lookup dataset according to the specified filter fields. All lookup entries matching any of the filter blocks are returned. To match a filter block, a lookup entry must match all the specified fields as if there were an `AND` operator between them. If no filters are specified, return all lookup entries. 

**Note:** 

- The maximum number of entries returned is 10,000.
- Requests time out after three minutes.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/xql/lookups/get_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_xql_lookups_get_data
post_public_api_v1_xql_lookups_get_data_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_get_triage_presets(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get all triage preset information including triage name, platform, description, created by, and triage type.

Required license: **Cortex XSIAM Premium** or **Forensics add-on**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/get_triage_presets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_get_triage_presets
post_public_api_v1_get_triage_presets_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_authentication_settings_create(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Create authentication settings for IdP SSO or metadata URL. You must include either the `metadata_url` field or all of the following fields: `idp_sso_url`, `idp_issuer`, and `idp_certificate`.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/authentication-settings/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_authentication_settings_create
post_public_api_v1_authentication_settings_create_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_authentication_settings_update(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Update existing authentication settings. To update the default domain, include empty value for both `current_domain_value` and `new_domain_value`.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/authentication-settings/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_authentication_settings_update
post_public_api_v1_authentication_settings_update_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_authentication_settings_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete all authentication settings for the specified domain. 

**Note: ** The first configuration on the tenant is the default configuration and cannot be deleted.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/authentication-settings/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_authentication_settings_delete
post_public_api_v1_authentication_settings_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_authentication_settings_get_settings(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get all the authentication settings for every configured domain in the tenant.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/authentication-settings/get/settings"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_authentication_settings_get_settings
post_public_api_v1_authentication_settings_get_settings_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_authentication_settings_get_metadata(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get the metadata for all IdPs.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/authentication-settings/get/metadata"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_authentication_settings_get_metadata
post_public_api_v1_authentication_settings_get_metadata_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_asm_management_upload_asm_data(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Upload domains (paid-level domains (PLD) and subdomains) and IPv4 address ranges. You can upload up to 500 IP address ranges or domains in each request.

You must have **Instance Administrator** permissions to run this endpoint.

Required license: **Cortex XSIAM Premium** or  Cortex XSIAM with ASM add-on
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/asm_management/upload_asm_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_asm_management_upload_asm_data
post_public_api_v1_asm_management_upload_asm_data_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_website(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get details about specific websites based on website IDs. You can submit up to 20 website IDs. 

Required license: **Cortex XSIAM Premium** or  Cortex XSIAM with ASM Add-on
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_website"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_website
post_public_api_v1_assets_get_external_website_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_websites(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of your public-facing websites. 

Required license: **Cortex XSIAM Premium** or  Cortex XSIAM with ASM Add-on

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_websites"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_websites
post_public_api_v1_assets_get_external_websites_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_assets_get_external_websites_last_external_assessment(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Gets the time and status of the last update of websites data in Cortex. A status of "true" indicates the websites data update was successful.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/assets/get_external_websites/last_external_assessment"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_assets_get_external_websites_last_external_assessment
post_public_api_v1_assets_get_external_websites_last_external_assessment_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "An empty dictionary returns the time and status of the last websites assessment."},
    },
}

@server.call_tool()
async def post_public_api_v1_integrations_syslog_create(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Create a new syslog integration.

You must have **View/Edit Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/integrations/syslog/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_integrations_syslog_create
post_public_api_v1_integrations_syslog_create_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_integrations_syslog_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of syslog servers.

You must have **View Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/integrations/syslog/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_integrations_syslog_get
post_public_api_v1_integrations_syslog_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def post_public_api_v1_integrations_syslog_update(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Update the details of the specified syslog integration.

You must have **View/Edit Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/integrations/syslog/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_integrations_syslog_update
post_public_api_v1_integrations_syslog_update_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_integrations_syslog_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete all the syslog integrations or the ones who match the filter criteria.

You must have **View/Edit Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/integrations/syslog/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_integrations_syslog_delete
post_public_api_v1_integrations_syslog_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary deletes all syslog servers."},
    },
}

@server.call_tool()
async def post_public_api_v1_integrations_syslog_test(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Tests a syslog integration's validity.

You must have **View Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/integrations/syslog/test"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_integrations_syslog_test
post_public_api_v1_integrations_syslog_test_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_entries_insert(
    authorization: str,
    x_xdr_auth_id: str,
    id: str | None = None,
    data: str | None = None,
) -> List[types.TextContent]:
    """
    Add an entry to the incident or alert War Room, including data.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if id is not None:
        body["id"] = id
    if data is not None:
        body["data"] = data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/entries/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_entries_insert
post_public_api_v1_entries_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "id": {"type": "str", "description": "The ID of the incident or alert for which you want to add a War Room entry. For an incident ID, prepend \"INCIDENT-\" to the incident ID. For example, if the incident ID is 3, the value of `id` should be `INCIDENT-3`. For alert IDs, just put the ID. For example, if the alert ID is 3, the value of `id` should be `3`."},
        "data": {"type": "str", "description": "The data you want to add or the command you want to run in the War Room."},
    },
}

@server.call_tool()
async def post_public_api_v1_entries_get(
    authorization: str,
    x_xdr_auth_id: str,
    id: str | None = None,
    filter: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get the War Room entries for a specific incident or alert. You can filter by timestamp, ID, and tags. You can also choose which type of entries you want to retrieve (notes, chat, attachments...).
The response depends on what type of entry you choose to retrieve.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if id is not None:
        body["id"] = id
    if filter is not None:
        body["filter"] = filter

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/entries/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_entries_get
post_public_api_v1_entries_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "id": {"type": "str", "description": "The ID of the incident or alert you want to get the War Room entries of. For an incident ID, prepend \"INCIDENT-\" to the incident ID. For example, if the incident ID is 3, the value of `id` should be `INCIDENT-3`. For alert IDs, just put the ID. For example, if the alert ID is 3, the value of `id` should be `3`."},
        "filter": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_distributions_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete an agent installation package. The distribution ID is required and can be found in the [Create distributions](https://docs-cortex.paloaltonetworks.com/r/ppPm_R5Omz9LsbjR8gZJbg/NIB~j5teUOLZlFNOhL3dZg) API response or in the **Agent Installations** screen in the Cortex Console.

**Note: ** Once you delete an installation package, it prevents new agents using the package, including VDI, from registering. 

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/distributions/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_distributions_delete
post_public_api_v1_distributions_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_asm_management_remove_asm_data(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Remove certificates, domains (paid-level domains and subdomains), and IPv4 address ranges from your inventory. Remove up to 500 certificates, domains, or IP ranges per request.

Removed assets appear the Asset Uploads/Removals table with the status **Removed**. Within 24 hours of submitting your request, assets are removed from the inventory. Within a few days, related incidents, alerts, and services are also removed.
You cannot remove an asset that was uploaded in a previous upload request. 

When you remove a paid-level domain, related subdomains are also removed. When you remove an IPv4 range, the individual IPv4 addresses in that range are also removed.

Required role: Instance Admin 

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM with ASM add-on**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/asm_management/remove_asm_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_asm_management_remove_asm_data
post_public_api_v1_asm_management_remove_asm_data_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api-key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api-key-id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def post_public_api_v1_scheduled_queries_list(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Return a list of scheduled queries. You can return all scheduled queries or filter results. You can also return extended results with all details included.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scheduled_queries/list"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_scheduled_queries_list
post_public_api_v1_scheduled_queries_list_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_scheduled_queries_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new scheduled queries or update existing scheduled queries. 

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scheduled_queries/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_scheduled_queries_insert
post_public_api_v1_scheduled_queries_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_scheduled_queries_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Delete scheduled queries.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scheduled_queries/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_scheduled_queries_delete
post_public_api_v1_scheduled_queries_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_xql_library_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve a detailed list of XQL query libraries. You can filter by list of query names or by list of query tags.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/xql_library/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_xql_library_get
post_public_api_xql_library_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_xql_library_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Insert new XQL queries or update existing XQL queries.

**Note:** You should use unique `xql_query_name` for each XQL query on a given tenant.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/xql_library/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_xql_library_insert
post_public_api_xql_library_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_xql_library_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete XQL queries. You can filter by list of query names or by list of query tags.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/xql_library/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_xql_library_delete
post_public_api_xql_library_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_indicators_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a list of IOCs. You can return all IOCs or filter results. You can also return extended results with all details included.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

UI navigation: **XSIAM** > **Detection & Threat Intel** > **Detection Rules** > **IOC**.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/indicators/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_indicators_get
post_public_api_v1_indicators_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_indicators_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new IOCs or update existing IOCs.

**Note:** The IOC `rule_id` is tenant specific and can't be used across tenants. Inserting IOCs with the same `rule_id` as an existing IOC on that tenant will overwrite the existing IOC.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/indicators/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_indicators_insert
post_public_api_v1_indicators_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_indicators_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete IOCs selected by filter.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/indicators/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_indicators_delete
post_public_api_v1_indicators_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_bioc_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Return a list of BIOCs. You can return all BIOCs or filter results. You can also return extended results with all details included.- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/bioc/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_bioc_get
post_public_api_v1_bioc_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_bioc_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new BIOCs or update existing BIOCs.

**Note:** The BIOC `rule_id` is tenant specific and can't be used across tenants. Inserting BIOCs with the same `rule_id` as an existing BIOC on that tenant will overwrite the existing BIOC.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/bioc/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_bioc_insert
post_public_api_v1_bioc_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_bioc_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete BIOCs selected by filter.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/bioc/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_bioc_delete
post_public_api_v1_bioc_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_correlations_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Return a list of correlation rules. You can return all correlation rules or filter results. You can also return extended results with all details included.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/correlations/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_correlations_get
post_public_api_v1_correlations_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_correlations_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new Correlation Rules or update existing Correlation Rules.

**Note:** The Correlation Rule `id` is tenant specific and can't be used across tenants. Inserting Correlation Rules with the same `id` as an existing Correlation Rule on that tenant will overwrite the existing Correlation Rule.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/correlations/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_correlations_insert
post_public_api_v1_correlations_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_correlations_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete correlation rules selected by filter.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/correlations/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_correlations_delete
post_public_api_v1_correlations_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_playbooks_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
     Get a playbook by filtering based on its name or ID. The playbook's YAML is returned in a ZIP file.

 You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/playbooks/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_playbooks_get
post_public_api_v1_playbooks_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_playbooks_insert(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Add or update a playbook by passing the YAML in a ZIP file.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/playbooks/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_playbooks_insert
post_public_api_v1_playbooks_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_public_api_v1_playbooks_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete a playbook by filtering based on its name or ID.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/playbooks/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_playbooks_delete
post_public_api_v1_playbooks_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_scripts_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
     Get a script by filtering based on its name or ID. The script's YAML is returned in a ZIP file.

 You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_scripts_get
post_public_api_v1_scripts_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_scripts_insert(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Update or add a script by passing the YAML in a ZIP file.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_scripts_insert
post_public_api_v1_scripts_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def post_public_api_v1_scripts_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete a script by filtering based on its name or ID.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/scripts/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_scripts_delete
post_public_api_v1_scripts_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_dashboards_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get dashboard details by filtering based on the dashboard name, dashboard ID, time the dashboard was generated, or dashboard source.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/dashboards/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_dashboards_get
post_public_api_v1_dashboards_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_dashboards_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add or update the dashboards retrieved by the Get dashboards API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/dashboards/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_dashboards_insert
post_public_api_v1_dashboards_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_dashboards_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete the dashboards retrieved by the Get dashboards API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/dashboards/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_dashboards_delete
post_public_api_v1_dashboards_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_widgets_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get widget details by filtering based on the widget title and widget creator.

**Note:** The endpoint only returns XQL widgets and not predefined widgets.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/widgets/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_widgets_get
post_public_api_v1_widgets_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_widgets_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Update or add the widgets retrieved by the Get widgets API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/widgets/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_widgets_insert
post_public_api_v1_widgets_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def post_public_api_v1_widgets_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete the widgets retrieved by the Get widgets API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = authorization
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = x_xdr_auth_id
    if request_data is not None:
        body["request_data"] = request_data

    # Build URL
    url = "https://api-yourfqdn/public_api/v1/widgets/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for post_public_api_v1_widgets_delete
post_public_api_v1_widgets_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}
