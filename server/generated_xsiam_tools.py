"""
Auto-generated MCP tools for XSIAM.
Generated from OpenAPI specification: xsiam.json

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by codegen/generator.py
"""

from typing import Any, Dict, List
import os
import re

import httpx
from mcp.server import Server
from mcp import types

# This will be set by the server initialization
server: Server = None  # type: ignore


def get_api_config() -> Dict[str, str]:
    """Get API configuration from environment variables."""
    return {
        "xsiam_api_url": os.getenv("XSIAM_API_URL", "https://api-yourfqdn"),
        "xsoar_api_url": os.getenv("XSOAR_API_URL", "https://your-xsoar-instance.com"),
        "timeout": int(os.getenv("API_TIMEOUT", "30")),
        "max_retries": int(os.getenv("API_MAX_RETRIES", "3")),
        "verify_ssl": os.getenv("VERIFY_SSL", "true").lower() == "true",
    }


def get_http_client() -> httpx.AsyncClient:
    """Create a configured HTTP client with security settings."""
    config = get_api_config()
    return httpx.AsyncClient(
        timeout=config["timeout"],
        verify=config["verify_ssl"],
        limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),
    )


def sanitize_input(value: Any) -> Any:
    """Sanitize user input to prevent injection attacks."""
    if isinstance(value, str):
        # Remove potentially dangerous characters
        # Allow alphanumeric, spaces, hyphens, underscores, and common punctuation
        sanitized = re.sub(r'[^\w\s\-_.@,:/]', '', value)
        # Limit length to prevent DoS
        return sanitized[:1000]
    return value


def validate_inputs(params: Dict[str, Any]) -> None:
    """Validate input parameters."""
    for key, value in params.items():
        if key == "self":  # Skip 'self' from locals()
            continue
        if value is not None and isinstance(value, str):
            # Check for extremely long inputs
            if len(value) > 10000:
                raise ValueError(f"Input parameter '{key}' exceeds maximum length")


def sanitize_error_message(error: str) -> str:
    """Sanitize error messages to prevent information leakage."""
    # Remove sensitive information patterns
    sanitized = re.sub(r'api[_-]?key[=:]?[\s]?[\w-]+', 'API_KEY_REDACTED', error, flags=re.IGNORECASE)
    sanitized = re.sub(r'token[=:]?[\s]?[\w-]+', 'TOKEN_REDACTED', sanitized, flags=re.IGNORECASE)
    sanitized = re.sub(r'password[=:]?[\s]?[\w-]+', 'PASSWORD_REDACTED', sanitized, flags=re.IGNORECASE)
    # Limit error message length
    return sanitized[:500]



def set_server(s: Server) -> None:
    """Set the server instance for tool registration."""
    global server
    server = s


@server.call_tool()
async def xsiam_start_xql_query(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Execute an XQL query.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/start_xql_query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_start_xql_query
xsiam_start_xql_query_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_query_results(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve results of an executed XQL query API. 

Note: This endpoint only works on XQL queries initiated by `/public_api/v1/xql/start_xql_query/`.

Maximum result set size is 1000. The API does not support pagination, therefore, you can set values to determine the result size limitation and how to wait for the results. To view response with greater than 1000 results you must call **Get XQL query results Stream**.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/get_query_results"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_query_results
xsiam_get_query_results_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_quota(

) -> List[types.TextContent]:
    """
    Retrieve the amount of query quota available and used. 

Note: This endpoint only works on XQL queries initiated by `/public_api/v1/xql/start_xql_query/`.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/get_quota"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_quota
xsiam_get_quota_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsiam_get_query_results_stream(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
    accept__encoding: str | None = None,
) -> List[types.TextContent]:
    """
    Retrieve XQL query results with more than 1000 results. 

Note: This endpoint only works on XQL queries initiated by `/public_api/v1/xql/start_xql_query/`.

Response is returned as chunked (Transfer-Encoding: chunked). To retrieve a compressed gzipped response (Content-Encoding: gzip), in your header add Accept-Encoding: gzip.

For more information on how to run XQL queries, see [*Running XQL query APIs*](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/90ay3tlx6l9dh-running-xql-query-ap-is).

<!-- theme: info -->

> #### Note
>
> To ensure you don't surpass your quota, Cortex XSIAM allows you to run up to four API queries in parallel.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if accept__encoding is not None:
        headers["Accept-Encoding"] = sanitize_input(accept__encoding)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/get_query_results_stream"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_query_results_stream
xsiam_get_query_results_stream_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "accept__encoding": {"type": "str", "description": "For retrieving a compressed gzipped response"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_incidents(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of incidents filtered by a list of incident IDs, modification time, or creation time.  This includes all incident types and severities, including correlation-generated incidents.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

Note: You can send a request to retrieve either **all** or **filtered** results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/incidents/get_incidents"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_incidents
xsiam_get_incidents_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_alerts_get_alerts_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of all or filtered alerts.  The alerts listed are what remains after alert exclusions are applied by Cortex XSIAM.

- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of alerts from the start of the result set.
The response indicates whether an PAN NGFW type alert contains a PCAP triggering packet. Use the Retrieve PCAP Packet API to retrieve a list of alert IDs and their associated PCAP data.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/get_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_alerts_get_alerts_v1
xsiam_alerts_get_alerts_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_alerts_get_alerts_multi_events_v2(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a list of alerts with multiple events.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is 100.
- Offset is the zero-based number of alerts from the start of the result set.

Cortex XDR displays in the API response whether a PAN NGFW type alert contains a PCAP triggering packet. Use the **Retrieve PCAP Packet** API to retrieve a list of alert IDs and their associated PCAP data.

Note: You can send a request to retrieve either all or filtered results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v2/alerts/get_alerts_multi_events"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_alerts_get_alerts_multi_events_v2
xsiam_alerts_get_alerts_multi_events_v2_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_get_alerts_multi_events(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    **Note: ** This endpoint is legacy. Use the [Get Alerts Multi-Events v2](https://cortex-panw.stoplight.io/docs/cortex-xsiam-1/guxcmlw6h3y8v-get-alerts-multi-events-v2) endpoint.

Get a list of alerts with multiple events.
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of alerts from the start of the result set.
Cortex XDR displays in the APIs response whether an PAN NGFW type alert contains a PCAP triggering packet. Use the Retrieve PCAP Packet API to retrieve a list of alert IDs and their associated PCAP data.

Note: You can send a request to retrieve either all or filtered results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/get_alerts_multi_events"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_alerts_multi_events
xsiam_get_alerts_multi_events_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_update_incident(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Update one or more fields of a specific incident. Missing fields are ignored.
**Note**:
- `assigned_user_mail` field is validated by Cortex XSIAM to confirm the provided assignee email address belongs to a user that exists in the same Cortex XSIAM tenant.
- To unassign an incident pass `none` or `"assigned_user_mail": ""`.
- To remove a manually set severity pass `none` or `"manual_severity": ""`.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/incidents/update_incident"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_update_incident
xsiam_update_incident_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_update_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Update one or more alerts. You can update up to 100 alerts per request. Missing fields are ignored.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/update_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_update_alerts
xsiam_update_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "(Required) A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_insert_cef_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Upload alerts in CEF format from external alert sources. After you map CEF alert fields to Cortex XDR fields, Cortex XDR displays the alerts in related incidents and views.
You can send 600 alerts per minute.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/insert_cef_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_insert_cef_alerts
xsiam_insert_cef_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_insert_parsed_alerts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Upload alerts from external alert sources in Cortex XSIAM format. Cortex XSIAM displays alerts that are parsed successfully in related incidents and views.
You can send 600 alerts per minute. Each request can contain a maximum of 60 alerts.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/insert_parsed_alerts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_insert_parsed_alerts
xsiam_insert_parsed_alerts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_alerts_pcap(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Retrieve a list of alert IDs and the associated PCAP triggering packets of PAN NGFW type alerts returned when running the **Get Alerts** and **Get Extra Incident Data** APIs. Maximum result set size is 100.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/get_alerts_pcap"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_alerts_pcap
xsiam_get_alerts_pcap_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_create_alert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Create a custom alert.

In addition to the mandatory fields (`vendor`, `product`, `severity`, `category`), any field that appears in the alert table can be used. In order to use a field from the alert table, use its lower camel case representation. For example: `Container ID` -> `container_id`. If the field in the alert table contains a hyphen, replace it with underscore, for example: `App - ID` -> `app_id`.

The following fields are recommended for creating an alert:
	- `remote_ip`
	- `remote_host`
	- `host_name`
	- `group_id`
	- `initiated_by`
	- `initiator_sha256`
	- `target_process_sha256`
	- `cgo_sha256`
	- `file_sha256`
	- `os_parent_cmd`
	- `os_parent_user_name`

By using multiple calls of `create_alert`, you can send up to 600 alerts per minute.

Required role: **App Service Account**

Required licenses: **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/alerts/create_alert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_create_alert
xsiam_create_alert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_replace_hosts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured hosts listed in your environment.

Note: Running this API will delete all existing host names.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/featured_fields/replace_hosts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_replace_hosts
xsiam_replace_hosts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_replace_users(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured users listed in your environment.

Note: Running this API will delete all existing user names.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/featured_fields/replace_users"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_replace_users
xsiam_replace_users_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_replace_ip_addresses(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured IP addresses listed in your environment.

Note: Running this API will delete all existing IP addresses.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/featured_fields/replace_ip_addresses"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_replace_ip_addresses
xsiam_replace_ip_addresses_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_replace_ad_groups(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Replace the featured active directory groups and organizational units listed in your environment.

Note: Running this API will delete all existing active directory groups.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/featured_fields/replace_ad_groups"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_replace_ad_groups
xsiam_replace_ad_groups_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_versions(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Get a list of all the agent versions to use for creating a distribution list.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/distributions/get_versions"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_versions
xsiam_get_versions_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_get_endpoints(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Gets a list of all of your endpoints. The response is concatenated using AND condition (OR is not supported).

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/get_endpoints"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_endpoints
xsiam_get_endpoints_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_get_policy(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the policy name for a specific endpoint.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/get_policy"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_policy
xsiam_get_policy_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete selected endpoints in the Cortex XDR app. You can delete up to 1000 endpoints.

Note: Endpoints are deleted from the Cortex XDR app web interface, however they still exist in the database.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 1000.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_delete
xsiam_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_create(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Create an installation package. This is an async call that returns the distribution ID; it does not mean that the creation succeeded. To confirm the package has been created, check the status of the distribution by running the **Get Distribution Status** API.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/distributions/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_create
xsiam_create_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_violations(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Gets a list of device control violations filtered by selected fields. You can retrieve up to 100 violations.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/device_control/get_violations"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_violations
xsiam_get_violations_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "An empty object returns all results."},
    },
}

@server.call_tool()
async def xsiam_get_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Check the status of the installation package.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/distributions/get_status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_status
xsiam_get_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_dist_url(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the distribution URL for downloading the installation package.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/distributions/get_dist_url"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_dist_url
xsiam_get_dist_url_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_update_agent_name(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Set or modify an Alias field for your endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/update_agent_name"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_update_agent_name
xsiam_update_agent_name_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_assign(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Assign one or more tags to one or more endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/tags/agents/assign"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assign
xsiam_assign_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_remove(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Remove one or more tags from one or more endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/tags/agents/remove"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_remove
xsiam_remove_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the following API request fields."},
    },
}

@server.call_tool()
async def xsiam_restore(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Restore a quarantined file on a requested endpoints.
When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/restore"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_restore
xsiam_restore_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_file_retrieval_details(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    View the API required to call in order to download the file retrieved by the **Retrieve File** API request according to the action ID.

The response contains a file hash you need to download and then unzip to view:
1. Download the file.

<!--
title: "Request Example"
-->
``` curl
curl -XPOST "https://api-{fqdn}/public_api/v1/download/<api_value>" 
-H "x-xdr-auth-id:{API_KEY_ID}"  
-H "Authorization:{API_KEY}" 
-H 'Content-Type:application/json' 
--output /tmp/file.zip
```
2. Unzip the file: `unzip /tmp/file.zip`

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/actions/file_retrieval_details"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_file_retrieval_details
xsiam_file_retrieval_details_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_allowlist(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Add files which do not exist in the allow or block lists to an allow list.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/hash_exceptions/allowlist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_allowlist
xsiam_allowlist_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the quarantine status for specified files.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/quarantine/status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_status
xsiam_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_quarantine(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Quarantine file on selected endpoints. You can select up to 1000 endpoints.

Note: A success response means that the request reached the defined endpoints, however if the file was not found there, no quarantine action will take place. To ensure if the file has been quarantined, check the Cortex XDR Action Center.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 1000.
- Offset is the zero-based number of incidents from the start of the result set.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/quarantine"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_quarantine
xsiam_quarantine_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_blocklist(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Add files which do not exist in the allow or block lists to a block list. You can view the block list in the UI at **Incident Response** > **Action Center** > **Block List**.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/hash_exceptions/blocklist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_blocklist
xsiam_blocklist_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_unisolate(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Reverse the isolation of one or more endpoints in single request.

Note: You can only send a request with either `endpoint_id` to unisolate one endpoint or with filters to unisolate more than one endpoint. An error is raised if you try to use both `endpoint_id` and the filters.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/unisolate"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_unisolate
xsiam_unisolate_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_abort_scan(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Cancel the scan of selected endpoints. A scan can only be aborted if the selected endpoints are in **Pending** or in **Progress** status.

When filtering by multiple fields:
- Response is concatenated using AND condition (OR is not supported).
- Offset is the zero-based number of endpoints from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/abort_scan"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_abort_scan
xsiam_abort_scan_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_scan(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Run a scan on selected endpoints.
- Response is concatenated using AND condition (OR is not supported).
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/scan"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scan
xsiam_scan_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_action_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the status of the requested actions according to the action ID.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/actions/get_action_status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_action_status
xsiam_get_action_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_run_snippet_code_script(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Initiate a new endpoint script execution action using provided snippet code. Cortex XDR supports sending your request in Base64.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/run_snippet_code_script"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_run_snippet_code_script
xsiam_run_snippet_code_script_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_run_script(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Initiate a new endpoint script execution action using a script from the script library. The script can be run on up to 1000 endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/run_script"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_run_script
xsiam_run_script_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_script_metadata(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the full definitions of a specific script in the scripts library.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get_script_metadata"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_script_metadata
xsiam_get_script_metadata_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_script_execution_status(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the status of a script execution action.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get_script_execution_status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_script_execution_status
xsiam_get_script_execution_status_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_scripts(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a list of scripts available in the scripts library.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get_scripts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_scripts
xsiam_get_scripts_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_get_script_execution_results(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the results of a script execution action.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get_script_execution_results"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_script_execution_results
xsiam_get_script_execution_results_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_script_execution_results_files(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the files retrieved from a specific endpoint during a script execution.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get_script_execution_results_files"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_script_execution_results_files
xsiam_get_script_execution_results_files_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_script_code(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get the code of a specific script in the script library.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get_script_code"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_script_code
xsiam_get_script_code_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_insert_csv(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: str,
    validate: bool | None = None,
) -> List[types.TextContent]:
    """
    Upload IOCs in CSV format that you retrieved from external threat intelligence sources. 

Note: Cortex XDR does not scan historic data, but rather only new incoming data.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data
    if validate is not None:
        body["validate"] = validate

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/indicators/insert_csv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_insert_csv
xsiam_insert_csv_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "str", "description": "The body of this request contains a JSON object with a single field: `request_data`. This field is required. Its value is as string containing two or more comma-separated lines. The first line must contain the CSV header. All subsequent lines must represent IOC data. Each line must include at a minimum the required CSV fields, which are identified below. To help you validate the upload, you can send a separate validate field to view an array of errors with an unsuccessful call. | Field | Description | | ----------- | ----------- | | indicator | (Required) String that identifies the indicator you want to insert into Cortex XDR. | | type | (Required) Keyword identifying the type of indicator. Valid values are: `HASH`, `IP`, `PATH`, `DOMAIN_NAME`, or `FILENAME` | | severity | (Required) Keyword identifying the indicator's severity. Valid values are: `INFO`, `LOW`, `MEDIUM`, `HIGH`, or `CRITICAL` | | expiration_date | Integer representing the indicator's expiration timestamp. This is a Unix epoch timestamp value, in milliseconds. If this indicator has no expiration, use `Never`. If this value is NULL, the indicator receives the indicator's type value with the default expiration date. Valid values are: 7 days, 30 days, 90 days, or 180 days | | comment | Comment string. | | reputation | Keyword representing the indicator's reputation. Valid values are: `GOOD`, `BAD`, `SUSPICIOUS`, or `UNKNOWN` | | reliability | Character representing the indicator's reliability rating. Valid values are A-F. A is the most reliable, F is the least. | | class | String representing the indicator class (for example, \"Malware\") | | vendor.name | String representing the name of the vendor who reported this indicator. | | vendor.reputation | Keyword representing the vendor's reputation. Valid values are: `GOOD`, `BAD`, `SUSPICIOUS`, or `UNKNOWN` | | vendor.reliability | Character representing the vendor's reliability rating. Valid values are A-F. A is the most reliable, F is the least. |"},
        "validate": {"type": "bool", "description": "Indicates whether to return an array of errors in the case of an unsuccessful update indicator API request."},
    },
}

@server.call_tool()
async def xsiam_insert_jsons(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
    validate: bool | None = None,
) -> List[types.TextContent]:
    """
    Upload IOCs as JSON objects that you retrieved from external threat intelligence sources.

Note: Cortex XSIAM does not scan historic data, rather only new incoming data.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data
    if validate is not None:
        body["validate"] = validate

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/indicators/insert_jsons"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_insert_jsons
xsiam_insert_jsons_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
        "validate": {"type": "bool", "description": "Whether to return an array of errors in the case of an unsuccessful update indicator API request."},
    },
}

@server.call_tool()
async def xsiam_management_logs(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get audit management logs.
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/audits/management_logs"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_management_logs
xsiam_management_logs_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_healthcheck(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Perform a health check of your Cortex XSIAM environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/healthcheck"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_healthcheck
xsiam_healthcheck_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_system_get_tenant_info_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get your tenant license information.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/system/get_tenant_info"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_system_get_tenant_info_v1
xsiam_system_get_tenant_info_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_incidents_get_incident_extra_data_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get extra data fields of a specific incident including alerts and key artifacts.

- Cortex XDR displays in the APIs response whether a PAN NGFW type alert contains a PCAP triggering packet.
Use the **Retrieve PCAP Packet** API to retrieve a list of alert IDs and their associated PCAP data.

Note: The API includes a limit rate of 10 API requests per minute.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/incidents/get_incident_extra_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_incidents_get_incident_extra_data_v1
xsiam_incidents_get_incident_extra_data_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_rbac_get_users_v1(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Retrieve a list of the current users in your environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/rbac/get_users"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_rbac_get_users_v1
xsiam_rbac_get_users_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_rbac_get_roles_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Retrieve information about one or more roles created in your environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/rbac/get_roles"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_rbac_get_roles_v1
xsiam_rbac_get_roles_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_rbac_get_user_group_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve a list of the current user emails associated with one or more user groups in your environment.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/rbac/get_user_group"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_rbac_get_user_group_v1
xsiam_rbac_get_user_group_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_rbac_set_user_role_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add or remove one or more users from a role.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/rbac/set_user_role"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_rbac_set_user_role_v1
xsiam_rbac_set_user_role_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_endpoints_get_endpoint_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Gets a list of filtered endpoints.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is 100.
- Offset is the zero-based number of endpoints from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/get_endpoint"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_endpoints_get_endpoint_v1
xsiam_endpoints_get_endpoint_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_get_risk_score_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve the risk score of a specific user or endpoint in your environment, along with the reason for the score.

Required license: **Cortex XSIAM Premium** or **Identity Threat Module**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/get_risk_score"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_risk_score_v1
xsiam_get_risk_score_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_get_risky_users_v1(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Retrieve a list of users with the highest risk score in your environment along with the reason affecting each score.

Required license: **Cortex XSIAM Premium** or **Identity Threat Module**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/get_risky_users"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_risky_users_v1
xsiam_get_risky_users_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_get_risky_hosts_v1(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Retrieve a list of endpoints with the highest risk score in your environment along with the reason for each score.

Required license: **Cortex XSIAM Premium** or **Identity Threat Module**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/get_risky_hosts"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_risky_hosts_v1
xsiam_get_risky_hosts_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_endpoints_file_retrieval_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve files from selected endpoints. You can retrieve up to 20 files, from no more than 10 endpoints.
- Response is concatenated using AND condition (OR is not supported).
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/file_retrieval"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_endpoints_file_retrieval_v1
xsiam_endpoints_file_retrieval_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_endpoints_isolate_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Isolate one or more endpoints in a single request. Request is limited to 1000 endpoints.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/endpoints/isolate"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_endpoints_isolate_v1
xsiam_endpoints_isolate_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_audits_agents_reports_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get agent event reports.
- Response is concatenated using AND condition (OR is not supported).
- Maximum result set size is 100.
- Offset is the zero-based number of incidents from the start of the result set.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/audits/agents_reports"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_audits_agents_reports_v1
xsiam_audits_agents_reports_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_service_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get service details according to the service ID. You can send up to 20 IDs.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise**, **Cortex XSIAM Enterprise Plus** or **Cortex XSIAM Premium**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_service"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_service_v1
xsiam_assets_get_external_service_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_services_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of all your external services.

The maximum result limit is 500.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise**, **Cortex XSIAM Enterprise Plus** or **Cortex XSIAM Premium**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_services"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_services_v1
xsiam_assets_get_external_services_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "api-key"},
        "x_xdr_auth_id": {"type": "str", "description": "api-key-id"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_assets_get_assets_internet_exposure_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of all your Internet exposure filtered by business units, externally detected providers, externally inferred CVEs, mac addresses, names, IP addresses, whether it has an XDR agent, whether it has active external services, and type.

The maximum result limit is 500 assets.

Note: You can send a request to retrieve either all or filtered results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_assets_internet_exposure"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_assets_internet_exposure_v1
xsiam_assets_get_assets_internet_exposure_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_assets_get_asset_internet_exposure_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get Internet exposure asset details according to the asset ID. You can send up to 20 IDs.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_asset_internet_exposure"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_asset_internet_exposure_v1
xsiam_assets_get_asset_internet_exposure_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_ip_address_ranges_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get a list of all your Internet exposure filtered by business units and organization handles.

The maximum result limit is 1000 ranges.

Note: You can send a request to retrieve either **all** or **filtered** results.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_ip_address_ranges"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_ip_address_ranges_v1
xsiam_assets_get_external_ip_address_ranges_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_ip_address_range_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get external IP address range details according to the range IDs. You can send up to 100 IDs.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_ip_address_range"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_ip_address_range_v1
xsiam_assets_get_external_ip_address_range_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_triage_endpoint_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Initiate forensics triage for the specified agents.
- Maximum of 10 concurrent triage actions at a time.
- Specified agents must have Forensics License enabled.
- Specified agents must be the same OS, Windows or macOS, but not a mixture of both.
- Specified configuration must have type "Online = True".

Required license: **Cortex XSIAM Premium** or  
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/triage_endpoint"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_triage_endpoint_v1
xsiam_triage_endpoint_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_assets_get_vulnerability_tests_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of vulnerability tests. Results include details about each test, including the number of services confirmed vulnerable.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_vulnerability_tests"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_vulnerability_tests_v1
xsiam_assets_get_vulnerability_tests_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_assets_bulk_update_vulnerability_tests_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Enable or disable vulnerability tests.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/bulk_update_vulnerability_tests"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_bulk_update_vulnerability_tests_v1
xsiam_assets_bulk_update_vulnerability_tests_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_dataset_define_dataset_v1(
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Define an XQL user dataset based on an existing BigQuery table created by the user.

**Note:** BigQuery table must be an existing table under public_access_user.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.

These APIs are only applicable from within the XSIAM Notebook environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/dataset/define_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_dataset_define_dataset_v1
xsiam_dataset_define_dataset_v1_schema = {
    "type": "object",
    "properties": {
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_dataset_get_created_datasets_v1(

) -> List[types.TextContent]:
    """
    Retrieve a list of all XQL user datasets created using the Cortex SDK.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.

These APIs are only applicable from within the XSIAM Notebook environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/dataset/get_created_datasets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_dataset_get_created_datasets_v1
xsiam_dataset_get_created_datasets_v1_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsiam_dataset_delete_dataset_v1(
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete an XQL user dataset that was created by the Cortex SDK.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**.

These APIs are only applicable from within the XSIAM Notebook environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/dataset/delete_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_dataset_delete_dataset_v1
xsiam_dataset_delete_dataset_v1_schema = {
    "type": "object",
    "properties": {
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_add_dataset_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add a dataset of type `lookup` with the specified name and schema.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/add_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_add_dataset_v1
xsiam_xql_add_dataset_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_delete_dataset_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete a dataset with the specified name. The following dataset types can be deleted: Lookup, Raw, User, Snapshot, and Correlation. You can only delete a dataset with dependencies by setting `force` to TRUE.

**Note:** The System dataset and other protected datasets cannot be deleted.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v2/xql/delete_dataset"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_delete_dataset_v1
xsiam_xql_delete_dataset_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_get_datasets_v1(
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Retrieve a list of all the datasets and their properties.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/get_datasets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_get_datasets_v1
xsiam_xql_get_datasets_v1_schema = {
    "type": "object",
    "properties": {
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_lookups_add_data_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add or update data in a lookup dataset.

When updating data, any field not specified in the `data` field, but specified on at least one of the rows, will be set to `None`.

The `/public_api/xql/lookups/add_data/`  endpoint does not support concurrent edits. Sending concurrent calls to this endpoint can cause data to be unintentionally overwritten or deleted. To allow sufficient time for each API call to complete its operation before initiating another one, assume that 1000 entries can be added per API every 10 seconds.

**Note: ** 

- The maximum size of a lookup dataset is 50 MB. Attemping to exceed this limit will fail.
- Requests time out after three minutes.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/lookups/add_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_lookups_add_data_v1
xsiam_xql_lookups_add_data_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_lookups_remove_data_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Remove data from a dataset based on the specified parameters. If any one of the filter sets are not found, the API does not delete any data.

The `/public_api/xql/lookups/remove_data/`  endpoint does not support concurrent edits. Sending concurrent calls to this endpoint can cause data to be unintentionally overwritten or deleted. To allow sufficient time for each API call to complete its operation before initiating another one, assume that 1000 entries can be added per API every 10 seconds.

**Note:** 
- All lookup entries matching any of the filter blocks are deleted. To match a filter block, a lookup entry must match all the specified fields as if there were an `AND` operator between them. 
- Requests time out after three minutes.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/lookups/remove_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_lookups_remove_data_v1
xsiam_xql_lookups_remove_data_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_lookups_get_data_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get data from a lookup dataset according to the specified filter fields. All lookup entries matching any of the filter blocks are returned. To match a filter block, a lookup entry must match all the specified fields as if there were an `AND` operator between them. If no filters are specified, return all lookup entries. 

**Note:** 

- The maximum number of entries returned is 10,000.
- Requests time out after three minutes.

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/xql/lookups/get_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_lookups_get_data_v1
xsiam_xql_lookups_get_data_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_get_triage_presets_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get all triage preset information including triage name, platform, description, created by, and triage type.

Required license: **Cortex XSIAM Premium** or **Forensics add-on**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/get_triage_presets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_get_triage_presets_v1
xsiam_get_triage_presets_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_authentication_settings_create_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Create authentication settings for IdP SSO or metadata URL. You must include either the `metadata_url` field or all of the following fields: `idp_sso_url`, `idp_issuer`, and `idp_certificate`.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/authentication-settings/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_authentication_settings_create_v1
xsiam_authentication_settings_create_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_authentication_settings_update_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Update existing authentication settings. To update the default domain, include empty value for both `current_domain_value` and `new_domain_value`.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/authentication-settings/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_authentication_settings_update_v1
xsiam_authentication_settings_update_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_authentication_settings_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete all authentication settings for the specified domain. 

**Note: ** The first configuration on the tenant is the default configuration and cannot be deleted.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/authentication-settings/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_authentication_settings_delete_v1
xsiam_authentication_settings_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_authentication_settings_get_settings_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get all the authentication settings for every configured domain in the tenant.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/authentication-settings/get/settings"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_authentication_settings_get_settings_v1
xsiam_authentication_settings_get_settings_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_authentication_settings_get_metadata_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get the metadata for all IdPs.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/authentication-settings/get/metadata"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_authentication_settings_get_metadata_v1
xsiam_authentication_settings_get_metadata_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_asm_management_upload_asm_data_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Upload domains (paid-level domains (PLD) and subdomains) and IPv4 address ranges. You can upload up to 500 IP address ranges or domains in each request.

You must have **Instance Administrator** permissions to run this endpoint.

Required license: **Cortex XSIAM Premium** or  Cortex XSIAM with ASM add-on
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/asm_management/upload_asm_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_asm_management_upload_asm_data_v1
xsiam_asm_management_upload_asm_data_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_website_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get details about specific websites based on website IDs. You can submit up to 20 website IDs. 

Required license: **Cortex XSIAM Premium** or  Cortex XSIAM with ASM Add-on
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_website"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_website_v1
xsiam_assets_get_external_website_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_websites_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of your public-facing websites. 

Required license: **Cortex XSIAM Premium** or  Cortex XSIAM with ASM Add-on

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_websites"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_websites_v1
xsiam_assets_get_external_websites_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_assets_get_external_websites_last_external_assessment_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Gets the time and status of the last update of websites data in Cortex. A status of "true" indicates the websites data update was successful.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/assets/get_external_websites/last_external_assessment"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_assets_get_external_websites_last_external_assessment_v1
xsiam_assets_get_external_websites_last_external_assessment_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "An empty dictionary returns the time and status of the last websites assessment."},
    },
}

@server.call_tool()
async def xsiam_integrations_syslog_create_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Create a new syslog integration.

You must have **View/Edit Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/integrations/syslog/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_integrations_syslog_create_v1
xsiam_integrations_syslog_create_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_integrations_syslog_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a complete or filtered list of syslog servers.

You must have **View Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/integrations/syslog/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_integrations_syslog_get_v1
xsiam_integrations_syslog_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary returns all results."},
    },
}

@server.call_tool()
async def xsiam_integrations_syslog_update_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Update the details of the specified syslog integration.

You must have **View/Edit Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/integrations/syslog/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_integrations_syslog_update_v1
xsiam_integrations_syslog_update_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_integrations_syslog_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete all the syslog integrations or the ones who match the filter criteria.

You must have **View/Edit Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/integrations/syslog/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_integrations_syslog_delete_v1
xsiam_integrations_syslog_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields. An empty dictionary deletes all syslog servers."},
    },
}

@server.call_tool()
async def xsiam_integrations_syslog_test_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Tests a syslog integration's validity.

You must have **View Alert Notification** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/integrations/syslog/test"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_integrations_syslog_test_v1
xsiam_integrations_syslog_test_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_entries_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    id: str | None = None,
    data: str | None = None,
) -> List[types.TextContent]:
    """
    Add an entry to the incident or alert War Room, including data.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if id is not None:
        body["id"] = id
    if data is not None:
        body["data"] = data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/entries/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_entries_insert_v1
xsiam_entries_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "id": {"type": "str", "description": "The ID of the incident or alert for which you want to add a War Room entry. For an incident ID, prepend \"INCIDENT-\" to the incident ID. For example, if the incident ID is 3, the value of `id` should be `INCIDENT-3`. For alert IDs, just put the ID. For example, if the alert ID is 3, the value of `id` should be `3`."},
        "data": {"type": "str", "description": "The data you want to add or the command you want to run in the War Room."},
    },
}

@server.call_tool()
async def xsiam_entries_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    id: str | None = None,
    filter: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Get the War Room entries for a specific incident or alert. You can filter by timestamp, ID, and tags. You can also choose which type of entries you want to retrieve (notes, chat, attachments...).
The response depends on what type of entry you choose to retrieve.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if id is not None:
        body["id"] = id
    if filter is not None:
        body["filter"] = filter

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/entries/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_entries_get_v1
xsiam_entries_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "id": {"type": "str", "description": "The ID of the incident or alert you want to get the War Room entries of. For an incident ID, prepend \"INCIDENT-\" to the incident ID. For example, if the incident ID is 3, the value of `id` should be `INCIDENT-3`. For alert IDs, just put the ID. For example, if the alert ID is 3, the value of `id` should be `3`."},
        "filter": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_distributions_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Delete an agent installation package. The distribution ID is required and can be found in the [Create distributions](https://docs-cortex.paloaltonetworks.com/r/ppPm_R5Omz9LsbjR8gZJbg/NIB~j5teUOLZlFNOhL3dZg) API response or in the **Agent Installations** screen in the Cortex Console.

**Note: ** Once you delete an installation package, it prevents new agents using the package, including VDI, from registering. 

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM Enterprise** or **Cortex XSIAM Enterprise Plus**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/distributions/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_distributions_delete_v1
xsiam_distributions_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_asm_management_remove_asm_data_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Remove certificates, domains (paid-level domains and subdomains), and IPv4 address ranges from your inventory. Remove up to 500 certificates, domains, or IP ranges per request.

Removed assets appear the Asset Uploads/Removals table with the status **Removed**. Within 24 hours of submitting your request, assets are removed from the inventory. Within a few days, related incidents, alerts, and services are also removed.
You cannot remove an asset that was uploaded in a previous upload request. 

When you remove a paid-level domain, related subdomains are also removed. When you remove an IPv4 range, the individual IPv4 addresses in that range are also removed.

Required role: Instance Admin 

Required license: **Cortex XSIAM Premium** or **Cortex XSIAM with ASM add-on**
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/asm_management/remove_asm_data"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_asm_management_remove_asm_data_v1
xsiam_asm_management_remove_asm_data_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api-key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api-key-id}"},
        "request_data": {"type": "Dict[str, Any]", "description": "A dictionary containing the API request fields."},
    },
}

@server.call_tool()
async def xsiam_scheduled_queries_list_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Return a list of scheduled queries. You can return all scheduled queries or filter results. You can also return extended results with all details included.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scheduled_queries/list"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scheduled_queries_list_v1
xsiam_scheduled_queries_list_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_scheduled_queries_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new scheduled queries or update existing scheduled queries. 

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scheduled_queries/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scheduled_queries_insert_v1
xsiam_scheduled_queries_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_scheduled_queries_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Delete scheduled queries.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scheduled_queries/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scheduled_queries_delete_v1
xsiam_scheduled_queries_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_library_get(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Retrieve a detailed list of XQL query libraries. You can filter by list of query names or by list of query tags.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/xql_library/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_library_get
xsiam_xql_library_get_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_library_insert(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Insert new XQL queries or update existing XQL queries.

**Note:** You should use unique `xql_query_name` for each XQL query on a given tenant.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/xql_library/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_library_insert
xsiam_xql_library_insert_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_xql_library_delete(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete XQL queries. You can filter by list of query names or by list of query tags.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/xql_library/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_xql_library_delete
xsiam_xql_library_delete_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_indicators_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get a list of IOCs. You can return all IOCs or filter results. You can also return extended results with all details included.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

UI navigation: **XSIAM** > **Detection & Threat Intel** > **Detection Rules** > **IOC**.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/indicators/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_indicators_get_v1
xsiam_indicators_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_indicators_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new IOCs or update existing IOCs.

**Note:** The IOC `rule_id` is tenant specific and can't be used across tenants. Inserting IOCs with the same `rule_id` as an existing IOC on that tenant will overwrite the existing IOC.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/indicators/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_indicators_insert_v1
xsiam_indicators_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_indicators_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete IOCs selected by filter.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/indicators/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_indicators_delete_v1
xsiam_indicators_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_bioc_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Return a list of BIOCs. You can return all BIOCs or filter results. You can also return extended results with all details included.- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/bioc/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_bioc_get_v1
xsiam_bioc_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_bioc_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new BIOCs or update existing BIOCs.

**Note:** The BIOC `rule_id` is tenant specific and can't be used across tenants. Inserting BIOCs with the same `rule_id` as an existing BIOC on that tenant will overwrite the existing BIOC.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/bioc/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_bioc_insert_v1
xsiam_bioc_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_bioc_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete BIOCs selected by filter.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/bioc/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_bioc_delete_v1
xsiam_bioc_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_correlations_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Return a list of correlation rules. You can return all correlation rules or filter results. You can also return extended results with all details included.
- The response is concatenated using AND condition (OR is not supported).
- The maximum result set size is >100.
- Offset is the zero-based number of incidents from the start of the result set.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/correlations/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_correlations_get_v1
xsiam_correlations_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_correlations_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any],
) -> List[types.TextContent]:
    """
    Insert new Correlation Rules or update existing Correlation Rules.

**Note:** The Correlation Rule `id` is tenant specific and can't be used across tenants. Inserting Correlation Rules with the same `id` as an existing Correlation Rule on that tenant will overwrite the existing Correlation Rule.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/correlations/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_correlations_insert_v1
xsiam_correlations_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_correlations_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete correlation rules selected by filter.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/correlations/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_correlations_delete_v1
xsiam_correlations_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_playbooks_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
     Get a playbook by filtering based on its name or ID. The playbook's YAML is returned in a ZIP file.

 You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/playbooks/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_playbooks_get_v1
xsiam_playbooks_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_playbooks_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Add or update a playbook by passing the YAML in a ZIP file.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/playbooks/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_playbooks_insert_v1
xsiam_playbooks_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_playbooks_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete a playbook by filtering based on its name or ID.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/playbooks/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_playbooks_delete_v1
xsiam_playbooks_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_scripts_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
     Get a script by filtering based on its name or ID. The script's YAML is returned in a ZIP file.

 You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scripts_get_v1
xsiam_scripts_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_scripts_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
) -> List[types.TextContent]:
    """
    Update or add a script by passing the YAML in a ZIP file.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scripts_insert_v1
xsiam_scripts_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
    },
}

@server.call_tool()
async def xsiam_scripts_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete a script by filtering based on its name or ID.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/scripts/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_scripts_delete_v1
xsiam_scripts_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_dashboards_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get dashboard details by filtering based on the dashboard name, dashboard ID, time the dashboard was generated, or dashboard source.

You must have **Instance Administrator** permissions to run this endpoint.

    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/dashboards/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_dashboards_get_v1
xsiam_dashboards_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_dashboards_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any] | None = None,
) -> List[types.TextContent]:
    """
    Add or update the dashboards retrieved by the Get dashboards API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/dashboards/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_dashboards_insert_v1
xsiam_dashboards_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_dashboards_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete the dashboards retrieved by the Get dashboards API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/dashboards/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_dashboards_delete_v1
xsiam_dashboards_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_widgets_get_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Get widget details by filtering based on the widget title and widget creator.

**Note:** The endpoint only returns XQL widgets and not predefined widgets.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/widgets/get"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_widgets_get_v1
xsiam_widgets_get_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_widgets_insert_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Update or add the widgets retrieved by the Get widgets API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/widgets/insert"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_widgets_insert_v1
xsiam_widgets_insert_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsiam_widgets_delete_v1(
    authorization: str,
    x_xdr_auth_id: str,
    request_data: Dict[str, Any],
) -> List[types.TextContent]:
    """
    Delete the widgets retrieved by the Get widgets API.

You must have **Instance Administrator** permissions to run this endpoint.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if authorization is not None:
        headers["Authorization"] = sanitize_input(authorization)
    if x_xdr_auth_id is not None:
        headers["x-xdr-auth-id"] = sanitize_input(x_xdr_auth_id)
    if request_data is not None:
        body["request_data"] = request_data

    # Get base URL from environment
    base_url = get_api_config().get("xsiam_api_url", "https://api-yourfqdn")
    url = base_url + "/public_api/v1/widgets/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsiam_widgets_delete_v1
xsiam_widgets_delete_v1_schema = {
    "type": "object",
    "properties": {
        "authorization": {"type": "str", "description": "{api_key}"},
        "x_xdr_auth_id": {"type": "str", "description": "{api_key_id}"},
        "request_data": {"type": "Dict[str, Any]", "description": ""},
    },
}
