"""
Auto-generated MCP tools for XSOAR.
Generated from OpenAPI specification: xsoar.json

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by codegen/generator.py
"""

from typing import Any, Dict, List

import httpx
from mcp.server import Server
from mcp import types

# This will be set by the server initialization
server: Server = None  # type: ignore


def set_server(s: Server) -> None:
    """Set the server instance for tool registration."""
    global server
    server = s


@server.call_tool()
async def revoke_user_api_key(
    username: str,
) -> List[types.TextContent]:
    """
    Revoke API Key for user
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = username

    # Build URL
    url = "/apikeys/revoke/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for revoke_user_api_key
revoke_user_api_key_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "The username which the API keys assigned to"},
    },
}

@server.call_tool()
async def save_or_update_script(

) -> List[types.TextContent]:
    """
    Create or update a given automation.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for save_or_update_script
save_or_update_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def copy_script(

) -> List[types.TextContent]:
    """
    Copy given automation
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/copy"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for copy_script
copy_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def delete_automation_script(

) -> List[types.TextContent]:
    """
    Delete a given automation from the system.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for delete_automation_script
delete_automation_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def import_script(

) -> List[types.TextContent]:
    """
    Import an automation to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for import_script
import_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_automation_scripts(

) -> List[types.TextContent]:
    """
    Search Automation by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_automation_scripts
get_automation_scripts_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def import_classifier(

) -> List[types.TextContent]:
    """
    Import a classifier to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/classifier/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for import_classifier
import_classifier_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def upload_content_packs(

) -> List[types.TextContent]:
    """
    Upload Pack to the Server. Can be used to upload a Pack for an offline scenario or a Pack that hasn't been released.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/contentpacks/installed/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for upload_content_packs
upload_content_packs_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def import_dashboard(

) -> List[types.TextContent]:
    """
    Import a dashboard to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/dashboards/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for import_dashboard
import_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def investigation_add_entry_handler(

) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for investigation_add_entry_handler
investigation_add_entry_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def download_file(
    entryid: str,
) -> List[types.TextContent]:
    """
    Download file from Cortex XSOAR by entry ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if entryid is not None:
        path_params["entryid"] = entryid

    # Build URL
    url = "/entry/download/{entryid}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for download_file
download_file_schema = {
    "type": "object",
    "properties": {
        "entryid": {"type": "str", "description": "Entry ID"},
    },
}

@server.call_tool()
async def investigation_add_entries_sync(

) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/execute/sync"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for investigation_add_entries_sync
investigation_add_entries_sync_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def entry_export_artifact(

) -> List[types.TextContent]:
    """
    Export an entry artifact
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/exportArtifact"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for entry_export_artifact
entry_export_artifact_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def investigation_add_formatted_entry_handler(

) -> List[types.TextContent]:
    """
    API to create a formatted entry (table/json/text/markdown/html) in existing investigation
Body example: {"investigationId":"1234","format":"table/json/text/markdown/html","contents":"entry content…"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/formatted"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for investigation_add_formatted_entry_handler
investigation_add_formatted_entry_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def update_entry_note(

) -> List[types.TextContent]:
    """
    API to mark entry as note, can be used also to remove the note
Body example: {"id":1\@1234","version":"-1","investigationId":"1234","data":"true/false"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/note"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for update_entry_note
update_entry_note_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def update_entry_tags_op(

) -> List[types.TextContent]:
    """
    API to set entry tags
Body example: {"id":"1\@1234","version":"-1","investigationId":"1234","tags":["tag1","tag2"]"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/tags"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for update_entry_tags_op
update_entry_tags_op_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def save_evidence(

) -> List[types.TextContent]:
    """
    Save an evidence entity
To update evidence custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/evidence"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for save_evidence
save_evidence_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def delete_evidence_op(

) -> List[types.TextContent]:
    """
    Delete an evidence entity
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/evidence/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for delete_evidence_op
delete_evidence_op_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def search_evidence(

) -> List[types.TextContent]:
    """
    Search for an evidence entutiy by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/evidence/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for search_evidence
search_evidence_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def health_handler(

) -> List[types.TextContent]:
    """
    Check if Cortex XSOAR server is available
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/health"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for health_handler
health_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_containers(

) -> List[types.TextContent]:
    """
    Gets info on the containers - amount of running, inactive and total containers
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/health/containers"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_containers
get_containers_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def create_incident(

) -> List[types.TextContent]:
    """
    Create or update incident according to JSON structure.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update

Use the 'createInvestigation\: true' to start the investigation process automatically. (by running a playbook based on incident type.)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_incident
create_incident_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def create_incidents_batch(

) -> List[types.TextContent]:
    """
    Update a batch of incidents.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batch"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_incidents_batch
create_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def export_incidents_to_csv_batch(

) -> List[types.TextContent]:
    """
    Exports an incidents batch to CSV file (returns file ID)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for export_incidents_to_csv_batch
export_incidents_to_csv_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def close_incidents_batch(

) -> List[types.TextContent]:
    """
    Closes an incidents batch
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batchClose"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for close_incidents_batch
close_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def delete_incidents_batch(

) -> List[types.TextContent]:
    """
    Deletes an incidents batch
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for delete_incidents_batch
delete_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_incident_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an incident CSV file that was exported, by ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/incident/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_incident_as_csv
get_incident_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def create_incident_json(

) -> List[types.TextContent]:
    """
    Create single incident from raw JSON, builds incident according to default mapping
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_incident_json
create_incident_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def incident_file_upload(
    id: str,
) -> List[types.TextContent]:
    """
    Add file attachement to an incidents
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/incident/upload/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for incident_file_upload
incident_file_upload_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Incident id to update"},
    },
}

@server.call_tool()
async def set_tags_field(
    id: str,
) -> List[types.TextContent]:
    """
    Sets the select values of a specific tags field. The values passed to the route override the existing select
values of the field. To reset the select values pass an empty array.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/incidentfield/tags/reset/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for set_tags_field
set_tags_field_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The machine name of the field prefixed with the type. For example indicator_tags or incident_dbotmirrortags"},
    },
}

@server.call_tool()
async def get_incidents_fields_by_incident_type(
    type: str,
) -> List[types.TextContent]:
    """
    Get all incident fields associated with incident type
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if type is not None:
        path_params["type"] = type

    # Build URL
    url = "/incidentfields/associatedTypes/{type}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_incidents_fields_by_incident_type
get_incidents_fields_by_incident_type_schema = {
    "type": "object",
    "properties": {
        "type": {"type": "str", "description": "the name (case sensitive) of the incident type"},
    },
}

@server.call_tool()
async def import_incident_fields(

) -> List[types.TextContent]:
    """
    Import an incident field to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidentfields/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for import_incident_fields
import_incident_fields_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def search_incidents(

) -> List[types.TextContent]:
    """
    Search incidents across all indices. You can filter by multiple options.

**Note:** You cannot paginate results in a multi-tenant environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidents/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for search_incidents
search_incidents_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def create_or_update_incident_type(

) -> List[types.TextContent]:
    """
    API to create new Incident Type
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidenttype"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_or_update_incident_type
create_or_update_incident_type_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def import_incident_types_handler(

) -> List[types.TextContent]:
    """
    Import an incident type to Cortex XSOAR.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidenttypes/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for import_incident_types_handler
import_incident_types_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def indicators_create(

) -> List[types.TextContent]:
    """
    Create an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicator/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for indicators_create
indicators_create_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def indicators_edit(

) -> List[types.TextContent]:
    """
    Edit an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicator/edit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for indicators_edit
indicators_edit_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def indicator_whitelist(

) -> List[types.TextContent]:
    """
    Whitelists or deletes an indicator entity
In order to delete an indicator and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicator/whitelist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for indicator_whitelist
indicator_whitelist_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def export_indicators_to_stix_batch(

) -> List[types.TextContent]:
    """
    Exports an indicators batch to STIX file (returns file ID)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/batch/export/stix"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for export_indicators_to_stix_batch
export_indicators_to_stix_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def export_indicators_to_csv_batch(

) -> List[types.TextContent]:
    """
    Exports an indicators batch to CSV file (returns file ID)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for export_indicators_to_csv_batch
export_indicators_to_csv_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def delete_indicators_batch(

) -> List[types.TextContent]:
    """
    Batch whitelist or delete indicators entities
In order to delete indicators and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for delete_indicators_batch
delete_indicators_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_indicators_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators CSV file that was exported, by ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/indicators/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_indicators_as_csv
get_indicators_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def create_feed_indicators_json(

) -> List[types.TextContent]:
    """
    Create indicators from raw JSON (similar to ingesting from a feed). Builds indicators according to the specified feed classifier,
or uses the default one if not specified.
Indicator properties (all optional except for value): **value** (string, required) | **type** (string) | **score** (number, 0-3,
default `0`, where `0` means None, `1` Good, `2` Suspicious, and `3` Bad) | **sourceBrand** (string, default `"External"`) | **sourceInstance**
(string, default `"External"`) | **reliability** (string, one of `"A - Completely reliable"`, `"B - Usually reliable"`, `"C - Fairly
reliable"`, `"D - Not usually reliable"`, `"E - Unreliable"`, `"F - Reliability cannot be judged"`) | **expirationPolicy** (string,
one of `"never"`, `"interval"`, `"indicatorType"`) | **expirationInterval** (number, in minutes)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/feed/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_feed_indicators_json
create_feed_indicators_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def indicators_search(

) -> List[types.TextContent]:
    """
    Search indicators by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for indicators_search
indicators_search_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_indicators_as_stix(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators STIX V2 file that was exported, by ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/indicators/stix/v2/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_indicators_as_stix
get_indicators_as_stix_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "STIX V2 file to fetch (returned from batch export to STIX call)"},
    },
}

@server.call_tool()
async def indicators_timeline_delete(

) -> List[types.TextContent]:
    """
    Delete indicators timeline by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/timeline/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for indicators_timeline_delete
indicators_timeline_delete_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def indicators_create_batch(

) -> List[types.TextContent]:
    """
    Create indicators from a file
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for indicators_create_batch
indicators_create_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def create_or_update_whitelisted(

) -> List[types.TextContent]:
    """
    Create or update excluded indicators list
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/whitelist/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_or_update_whitelisted
create_or_update_whitelisted_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def add_ad_hoc_task(
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Add an ad-hoc task to a running playbook
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        path_params["investigationId"] = investigation_id

    # Build URL
    url = "/inv-playbook/task/add/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for add_ad_hoc_task
add_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def task_assign(

) -> List[types.TextContent]:
    """
    Assign a task to an owner
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/assign"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for task_assign
task_assign_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def complete_task(

) -> List[types.TextContent]:
    """
    Complete a task with a file attachment
Deprecated - use "/v2/inv-playbook/task/complete"
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for complete_task
complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def simple_complete_task(

) -> List[types.TextContent]:
    """
    Complete a task without a file attachment
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/complete/simple"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for simple_complete_task
simple_complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def delete_ad_hoc_task(
    inv_pb_task_id: str,
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Delete an ad-hoc task from a running playbook
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if inv_pb_task_id is not None:
        path_params["invPBTaskId"] = inv_pb_task_id
    if investigation_id is not None:
        path_params["investigationId"] = investigation_id

    # Build URL
    url = "/inv-playbook/task/delete/{investigationId}/{invPBTaskId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for delete_ad_hoc_task
delete_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "inv_pb_task_id": {"type": "str", "description": "ad-hoc task ID"},
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def task_set_due(

) -> List[types.TextContent]:
    """
    Set the task due date
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/due"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for task_set_due
task_set_due_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def edit_ad_hoc_task(
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Edit an ad-hoc task in a running playbook
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        path_params["investigationId"] = investigation_id

    # Build URL
    url = "/inv-playbook/task/edit/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for edit_ad_hoc_task
edit_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def task_add_comment(

) -> List[types.TextContent]:
    """
    Add comment to a task
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/note/add"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for task_add_comment
task_add_comment_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def task_un_complete(

) -> List[types.TextContent]:
    """
    Reopen a closed task and change the status to uncomplete
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/uncomplete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for task_un_complete
task_un_complete_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def search_investigations(

) -> List[types.TextContent]:
    """
    This will search investigations across all indices
You can filter by multiple options
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/investigations/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for search_investigations
search_investigations_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def logout_everyone_handler(

) -> List[types.TextContent]:
    """
    Sign out all open users sessions
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/logout/everyone"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for logout_everyone_handler
logout_everyone_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def logout_myself_handler(

) -> List[types.TextContent]:
    """
    Sign out all my open sessions
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/logout/myself"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for logout_myself_handler
logout_myself_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def logout_myself_other_sessions_handler(

) -> List[types.TextContent]:
    """
    Sign out all my other open sessions
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/logout/myself/other"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for logout_myself_other_sessions_handler
logout_myself_other_sessions_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def logout_user_sessions_handler(
    username: str,
) -> List[types.TextContent]:
    """
    Sign out all sessions of the provided username
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = username

    # Build URL
    url = "/logout/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for logout_user_sessions_handler
logout_user_sessions_handler_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "Username to logout"},
    },
}

@server.call_tool()
async def override_playbook_yaml(

) -> List[types.TextContent]:
    """
    Import and override playbook in Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/playbook/save/yaml"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for override_playbook_yaml
override_playbook_yaml_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def download_latest_report(
    id: str,
) -> List[types.TextContent]:
    """
    Get the latest report by its ID.

**Note:** To get the report, it must be a scheduled report with recipients.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/report/{id}/latest"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for download_latest_report
download_latest_report_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def execute_report(
    request_id: str,
    id: str,
) -> List[types.TextContent]:
    """
    Execute a new report
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_id is not None:
        path_params["requestId"] = request_id
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/report/{id}/{requestId}/execute"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for execute_report
execute_report_schema = {
    "type": "object",
    "properties": {
        "request_id": {"type": "str", "description": "the ID to register the request under"},
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def get_all_reports(

) -> List[types.TextContent]:
    """
    Get all of the reports
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/reports"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_all_reports
get_all_reports_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def upload_report(

) -> List[types.TextContent]:
    """
    Upload a report to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/reports/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for upload_report
upload_report_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_report_by_id(
    id: str,
) -> List[types.TextContent]:
    """
    Get a report by its ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/reports/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_report_by_id
get_report_by_id_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def get_audits(

) -> List[types.TextContent]:
    """
    Get audits by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/audits"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_audits
get_audits_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_docker_images(

) -> List[types.TextContent]:
    """
    Get list of all available docker image names
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_docker_images
get_docker_images_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def create_docker_image(

) -> List[types.TextContent]:
    """
    Create an image with a given list of dependencies
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for create_docker_image
create_docker_image_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def integration_upload(

) -> List[types.TextContent]:
    """
    Upload an integration to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/integration-conf/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for integration_upload
integration_upload_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def reset_roi_widget(

) -> List[types.TextContent]:
    """
    Reset ROI widget
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/statistics/application/roi"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="DELETE",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for reset_roi_widget
reset_roi_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_stats_for_dashboard_old_format(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
Deprecated - use "/v2/statistics/dashboards/query
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_stats_for_dashboard_old_format
get_stats_for_dashboard_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_stats_for_widget_old_format(

) -> List[types.TextContent]:
    """
    Get a given widget object statistics result.
Note: This route has many return types based on the widget type and data. Each 200X represent a 200 OK request of specific widget type and data

Deprecated - use "/v2/statistics/widgets/query
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_stats_for_widget_old_format
get_stats_for_widget_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def complete_task_v2(

) -> List[types.TextContent]:
    """
    Complete a task with command and multiple file attachments
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for complete_task_v2
complete_task_v2_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def submit_task_form(

) -> List[types.TextContent]:
    """
    Submit a data collection task with given answers and multiple file attachments
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/inv-playbook/task/form/submit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for submit_task_form
submit_task_form_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_stats_for_dashboard(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_stats_for_dashboard
get_stats_for_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_stats_for_widget(

) -> List[types.TextContent]:
    """
    Get the statistics for the specified widget.
**Note:** This endpoint has many return types depending on the widget type and data. Each 200X represents a 200 OK request of specific widget type and data.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_stats_for_widget
get_stats_for_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_all_widgets(

) -> List[types.TextContent]:
    """
    Get all widgets
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_all_widgets
get_all_widgets_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def save_widget(

) -> List[types.TextContent]:
    """
    Add or update a given widget based on Id.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for save_widget
save_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def import_widget(

) -> List[types.TextContent]:
    """
    Import a widget to the system, ignoring ID or version, used to import new widgets.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/widgets/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for import_widget
import_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def get_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Get a widget object by a given ID.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for get_widget
get_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The ID of widget to get."},
    },
}

@server.call_tool()
async def delete_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Remove a given widget Id from the system.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="DELETE",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for delete_widget
delete_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Widget id to remove (returned from widget save or widgets get)"},
    },
}

@server.call_tool()
async def workers_status_handler(

) -> List[types.TextContent]:
    """
    Get workers status
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/workers/status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for workers_status_handler
workers_status_handler_schema = {
    "type": "object",
    "properties": {

    },
}
