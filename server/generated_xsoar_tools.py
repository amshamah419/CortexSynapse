"""
Auto-generated MCP tools for XSOAR.
Generated from OpenAPI specification: xsoar.json

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by codegen/generator.py
"""

from typing import Any, Dict, List
import os
import re

import httpx
from mcp.server import Server
from mcp import types

# This will be set by the server initialization
server: Server = None  # type: ignore


def get_api_config() -> Dict[str, str]:
    """Get API configuration from environment variables."""
    return {
        "xsiam_api_url": os.getenv("XSIAM_API_URL", "https://api-yourfqdn"),
        "xsoar_api_url": os.getenv("XSOAR_API_URL", "https://your-xsoar-instance.com"),
        "timeout": int(os.getenv("API_TIMEOUT", "30")),
        "max_retries": int(os.getenv("API_MAX_RETRIES", "3")),
        "verify_ssl": os.getenv("VERIFY_SSL", "true").lower() == "true",
    }


def get_http_client() -> httpx.AsyncClient:
    """Create a configured HTTP client with security settings."""
    config = get_api_config()
    return httpx.AsyncClient(
        timeout=config["timeout"],
        verify=config["verify_ssl"],
        limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),
    )


def sanitize_input(value: Any) -> Any:
    """Sanitize user input to prevent injection attacks."""
    if isinstance(value, str):
        # Remove potentially dangerous characters
        # Allow alphanumeric, spaces, hyphens, underscores, and common punctuation
        sanitized = re.sub(r'[^\w\s\-_.@,:/]', '', value)
        # Limit length to prevent DoS
        return sanitized[:1000]
    return value


def validate_inputs(params: Dict[str, Any]) -> None:
    """Validate input parameters."""
    for key, value in params.items():
        if key == "self":  # Skip 'self' from locals()
            continue
        if value is not None and isinstance(value, str):
            # Check for extremely long inputs
            if len(value) > 10000:
                raise ValueError(f"Input parameter '{key}' exceeds maximum length")


def sanitize_error_message(error: str) -> str:
    """Sanitize error messages to prevent information leakage."""
    # Remove sensitive information patterns
    sanitized = re.sub(r'api[_-]?key[=:]?[\s]?[\w-]+', 'API_KEY_REDACTED', error, flags=re.IGNORECASE)
    sanitized = re.sub(r'token[=:]?[\s]?[\w-]+', 'TOKEN_REDACTED', sanitized, flags=re.IGNORECASE)
    sanitized = re.sub(r'password[=:]?[\s]?[\w-]+', 'PASSWORD_REDACTED', sanitized, flags=re.IGNORECASE)
    # Limit error message length
    return sanitized[:500]



def set_server(s: Server) -> None:
    """Set the server instance for tool registration."""
    global server
    server = s


@server.call_tool()
async def xsoar_revoke_user_api_key(
    username: str,
) -> List[types.TextContent]:
    """
    Revoke API Key for user
    
    Args:
        username (str): The username which the API keys assigned to (required)
    
    Returns:
        List[types.TextContent]: 200 for success
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = sanitize_input(username)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/apikeys/revoke/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_revoke_user_api_key
xsoar_revoke_user_api_key_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "The username which the API keys assigned to"},
    },
}

@server.call_tool()
async def xsoar_save_or_update_script(
    filter: str | None = None,
    save_password: bool | None = None,
    script: str | None = None,
) -> List[types.TextContent]:
    """
    Create or update a given automation.
    
    Args:
        filter (str): No description provided (optional)
        save_password (bool): No description provided (optional)
        script (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: The saved automation.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if filter is not None:
        body["filter"] = filter
    if save_password is not None:
        body["savePassword"] = save_password
    if script is not None:
        body["script"] = script

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_or_update_script
xsoar_save_or_update_script_schema = {
    "type": "object",
    "properties": {
        "filter": {"type": "str", "description": ""},
        "save_password": {"type": "bool", "description": ""},
        "script": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_copy_script(
    filter: str | None = None,
    save_password: bool | None = None,
    script: str | None = None,
) -> List[types.TextContent]:
    """
    Copy given automation
    
    Args:
        filter (str): No description provided (optional)
        save_password (bool): No description provided (optional)
        script (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: The saved automation.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if filter is not None:
        body["filter"] = filter
    if save_password is not None:
        body["savePassword"] = save_password
    if script is not None:
        body["script"] = script

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/copy"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_copy_script
xsoar_copy_script_schema = {
    "type": "object",
    "properties": {
        "filter": {"type": "str", "description": ""},
        "save_password": {"type": "bool", "description": ""},
        "script": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_delete_automation_script(
    filter: str | None = None,
    save_password: bool | None = None,
    script: str | None = None,
) -> List[types.TextContent]:
    """
    Delete a given automation from the system.
    
    Args:
        filter (str): No description provided (optional)
        save_password (bool): No description provided (optional)
        script (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: automation deleted
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if filter is not None:
        body["filter"] = filter
    if save_password is not None:
        body["savePassword"] = save_password
    if script is not None:
        body["script"] = script

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_automation_script
xsoar_delete_automation_script_schema = {
    "type": "object",
    "properties": {
        "filter": {"type": "str", "description": ""},
        "save_password": {"type": "bool", "description": ""},
        "script": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_import_script(

) -> List[types.TextContent]:
    """
    Import an automation to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved automation
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_script
xsoar_import_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_automation_scripts(
    cache: Dict[str, Any] | None = None,
    ignore_workers: bool | None = None,
    page: int | None = None,
    query: str | None = None,
    search_after: List[Any] | None = None,
    search_after_elastic: List[Any] | None = None,
    search_after_map: Dict[str, Any] | None = None,
    search_after_map_order: Dict[str, Any] | None = None,
    search_before: List[Any] | None = None,
    search_before_elastic: List[Any] | None = None,
    size: int | None = None,
    sort: List[Any] | None = None,
    strip_context: bool | None = None,
) -> List[types.TextContent]:
    """
    Search Automation by filter
    
    Args:
        cache (Dict[str, Any]): Cache of join functions (optional)
        ignore_workers (bool): Do not use workers mechanism while searching bleve (optional)
        page (int): 0-based page (optional)
        query (str): No description provided (optional)
        search_after (List[Any]): Efficient next page, pass max sort value from previous page (optional)
        search_after_elastic (List[Any]): Efficient next page, pass max ES sort value from previous page (optional)
        search_after_map (Dict[str, Any]): Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map. (optional)
        search_after_map_order (Dict[str, Any]): No description provided (optional)
        search_before (List[Any]): Efficient prev page, pass min sort value from next page (optional)
        search_before_elastic (List[Any]): Efficient prev page, pass min ES sort value from next page (optional)
        size (int): Size is limited to 1000, if not passed it defaults to 0, and no results will return (optional)
        sort (List[Any]): The sort order (optional)
        strip_context (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: automationScriptResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if cache is not None:
        body["Cache"] = cache
    if ignore_workers is not None:
        body["ignoreWorkers"] = ignore_workers
    if page is not None:
        body["page"] = page
    if query is not None:
        body["query"] = query
    if search_after is not None:
        body["searchAfter"] = search_after
    if search_after_elastic is not None:
        body["searchAfterElastic"] = search_after_elastic
    if search_after_map is not None:
        body["searchAfterMap"] = search_after_map
    if search_after_map_order is not None:
        body["searchAfterMapOrder"] = search_after_map_order
    if search_before is not None:
        body["searchBefore"] = search_before
    if search_before_elastic is not None:
        body["searchBeforeElastic"] = search_before_elastic
    if size is not None:
        body["size"] = size
    if sort is not None:
        body["sort"] = sort
    if strip_context is not None:
        body["stripContext"] = strip_context

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_automation_scripts
xsoar_get_automation_scripts_schema = {
    "type": "object",
    "properties": {
        "cache": {"type": "Dict[str, Any]", "description": "Cache of join functions"},
        "ignore_workers": {"type": "bool", "description": "Do not use workers mechanism while searching bleve"},
        "page": {"type": "int", "description": "0-based page"},
        "query": {"type": "str", "description": ""},
        "search_after": {"type": "List[Any]", "description": "Efficient next page, pass max sort value from previous page"},
        "search_after_elastic": {"type": "List[Any]", "description": "Efficient next page, pass max ES sort value from previous page"},
        "search_after_map": {"type": "Dict[str, Any]", "description": "Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map."},
        "search_after_map_order": {"type": "Dict[str, Any]", "description": ""},
        "search_before": {"type": "List[Any]", "description": "Efficient prev page, pass min sort value from next page"},
        "search_before_elastic": {"type": "List[Any]", "description": "Efficient prev page, pass min ES sort value from next page"},
        "size": {"type": "int", "description": "Size is limited to 1000, if not passed it defaults to 0, and no results will return"},
        "sort": {"type": "List[Any]", "description": "The sort order"},
        "strip_context": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_import_classifier(

) -> List[types.TextContent]:
    """
    Import a classifier to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved classifiers
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/classifier/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_classifier
xsoar_import_classifier_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_upload_content_packs(

) -> List[types.TextContent]:
    """
    Upload Pack to the Server. Can be used to upload a Pack for an offline scenario or a Pack that hasn't been released.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The pack was successfully uploaded
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/contentpacks/installed/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_upload_content_packs
xsoar_upload_content_packs_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_dashboard(

) -> List[types.TextContent]:
    """
    Import a dashboard to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved dashboard
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/dashboards/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_dashboard
xsoar_import_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_investigation_add_entry_handler(
    args: Dict[str, Any] | None = None,
    data: str | None = None,
    id: str | None = None,
    investigation_id: str | None = None,
    markdown: bool | None = None,
    primary_term: int | None = None,
    sequence_number: int | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        args (Dict[str, Any]): No description provided (optional)
        data (str): No description provided (optional)
        id (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
        markdown (bool): No description provided (optional)
        primary_term (int): No description provided (optional)
        sequence_number (int): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if args is not None:
        body["args"] = args
    if data is not None:
        body["data"] = data
    if id is not None:
        body["id"] = id
    if investigation_id is not None:
        body["investigationId"] = investigation_id
    if markdown is not None:
        body["markdown"] = markdown
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_entry_handler
xsoar_investigation_add_entry_handler_schema = {
    "type": "object",
    "properties": {
        "args": {"type": "Dict[str, Any]", "description": ""},
        "data": {"type": "str", "description": ""},
        "id": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
        "markdown": {"type": "bool", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_download_file(
    entryid: str,
) -> List[types.TextContent]:
    """
    Download file from Cortex XSOAR by entry ID
    
    Args:
        entryid (str): Entry ID (required)
    
    Returns:
        List[types.TextContent]: Return the entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if entryid is not None:
        path_params["entryid"] = sanitize_input(entryid)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/download/{entryid}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_download_file
xsoar_download_file_schema = {
    "type": "object",
    "properties": {
        "entryid": {"type": "str", "description": "Entry ID"},
    },
}

@server.call_tool()
async def xsoar_investigation_add_entries_sync(
    args: Dict[str, Any] | None = None,
    data: str | None = None,
    id: str | None = None,
    investigation_id: str | None = None,
    markdown: bool | None = None,
    primary_term: int | None = None,
    sequence_number: int | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        args (Dict[str, Any]): No description provided (optional)
        data (str): No description provided (optional)
        id (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
        markdown (bool): No description provided (optional)
        primary_term (int): No description provided (optional)
        sequence_number (int): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: An array of the children entries of the executed entry.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if args is not None:
        body["args"] = args
    if data is not None:
        body["data"] = data
    if id is not None:
        body["id"] = id
    if investigation_id is not None:
        body["investigationId"] = investigation_id
    if markdown is not None:
        body["markdown"] = markdown
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/execute/sync"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_entries_sync
xsoar_investigation_add_entries_sync_schema = {
    "type": "object",
    "properties": {
        "args": {"type": "Dict[str, Any]", "description": ""},
        "data": {"type": "str", "description": ""},
        "id": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
        "markdown": {"type": "bool", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_entry_export_artifact(
    id: str | None = None,
    investigation_id: str | None = None,
) -> List[types.TextContent]:
    """
    Export an entry artifact
    
    Args:
        id (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: created file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        body["id"] = id
    if investigation_id is not None:
        body["investigationId"] = investigation_id

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/exportArtifact"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_entry_export_artifact
xsoar_entry_export_artifact_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_investigation_add_formatted_entry_handler(
    contents: str | None = None,
    format: str | None = None,
    investigation_id: str | None = None,
) -> List[types.TextContent]:
    """
    API to create a formatted entry (table/json/text/markdown/html) in existing investigation
Body example: {"investigationId":"1234","format":"table/json/text/markdown/html","contents":"entry content…"}
    
    Args:
        contents (str): No description provided (optional)
        format (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if contents is not None:
        body["contents"] = contents
    if format is not None:
        body["format"] = format
    if investigation_id is not None:
        body["investigationId"] = investigation_id

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/formatted"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_formatted_entry_handler
xsoar_investigation_add_formatted_entry_handler_schema = {
    "type": "object",
    "properties": {
        "contents": {"type": "str", "description": ""},
        "format": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_update_entry_note(
    args: Dict[str, Any] | None = None,
    data: str | None = None,
    id: str | None = None,
    investigation_id: str | None = None,
    markdown: bool | None = None,
    primary_term: int | None = None,
    sequence_number: int | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    API to mark entry as note, can be used also to remove the note
Body example: {"id":1\@1234","version":"-1","investigationId":"1234","data":"true/false"}
    
    Args:
        args (Dict[str, Any]): No description provided (optional)
        data (str): No description provided (optional)
        id (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
        markdown (bool): No description provided (optional)
        primary_term (int): No description provided (optional)
        sequence_number (int): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if args is not None:
        body["args"] = args
    if data is not None:
        body["data"] = data
    if id is not None:
        body["id"] = id
    if investigation_id is not None:
        body["investigationId"] = investigation_id
    if markdown is not None:
        body["markdown"] = markdown
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/note"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_update_entry_note
xsoar_update_entry_note_schema = {
    "type": "object",
    "properties": {
        "args": {"type": "Dict[str, Any]", "description": ""},
        "data": {"type": "str", "description": ""},
        "id": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
        "markdown": {"type": "bool", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_update_entry_tags_op(
    id: str | None = None,
    investigation_id: str | None = None,
    primary_term: int | None = None,
    sequence_number: int | None = None,
    tags: List[Any] | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    API to set entry tags
Body example: {"id":"1\@1234","version":"-1","investigationId":"1234","tags":["tag1","tag2"]"}
    
    Args:
        id (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
        primary_term (int): No description provided (optional)
        sequence_number (int): No description provided (optional)
        tags (List[Any]): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        body["id"] = id
    if investigation_id is not None:
        body["investigationId"] = investigation_id
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if tags is not None:
        body["tags"] = tags
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/tags"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_update_entry_tags_op
xsoar_update_entry_tags_op_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "tags": {"type": "List[Any]", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_save_evidence(
    shard_id: int | None = None,
    all_read: bool | None = None,
    all_read_write: bool | None = None,
    cache_versn: int | None = None,
    created: str | None = None,
    dbot_created_by: str | None = None,
    description: str | None = None,
    entry_id: str | None = None,
    fetched: str | None = None,
    has_role: bool | None = None,
    highlight: Dict[str, Any] | None = None,
    id: str | None = None,
    incident_id: str | None = None,
    index_name: str | None = None,
    marked_by: str | None = None,
    marked_date: str | None = None,
    modified: str | None = None,
    numeric_id: int | None = None,
    occurred: str | None = None,
    previous_all_read: bool | None = None,
    previous_all_read_write: bool | None = None,
    previous_roles: List[Any] | None = None,
    primary_term: int | None = None,
    roles: List[Any] | None = None,
    sequence_number: int | None = None,
    size_in_bytes: int | None = None,
    sort_values: List[Any] | None = None,
    sync_hash: str | None = None,
    tags: List[Any] | None = None,
    tags_raw: List[Any] | None = None,
    task_id: str | None = None,
    version: int | None = None,
    xsoar_has_read_only_role: bool | None = None,
    xsoar_previous_read_only_roles: List[Any] | None = None,
    xsoar_read_only_roles: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Save an evidence entity
To update evidence custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        shard_id (int): No description provided (optional)
        all_read (bool): No description provided (optional)
        all_read_write (bool): No description provided (optional)
        cache_versn (int): No description provided (optional)
        created (str): No description provided (optional)
        dbot_created_by (str): Who has created this event - relevant only for manual incidents (optional)
        description (str): The description for the resolve (optional)
        entry_id (str): The entry ID (optional)
        fetched (str): when the evidence entry was fetched (optional)
        has_role (bool): Internal field to make queries on role faster (optional)
        highlight (Dict[str, Any]): No description provided (optional)
        id (str): No description provided (optional)
        incident_id (str): The incident ID (optional)
        index_name (str): No description provided (optional)
        marked_by (str): the user that marked this evidence (optional)
        marked_date (str): when this evidence was marked (optional)
        modified (str): No description provided (optional)
        numeric_id (int): No description provided (optional)
        occurred (str): When this evidence has occurred (optional)
        previous_all_read (bool): No description provided (optional)
        previous_all_read_write (bool): No description provided (optional)
        previous_roles (List[Any]): Do not change this field manually (optional)
        primary_term (int): No description provided (optional)
        roles (List[Any]): The role assigned to this investigation (optional)
        sequence_number (int): No description provided (optional)
        size_in_bytes (int): No description provided (optional)
        sort_values (List[Any]): No description provided (optional)
        sync_hash (str): No description provided (optional)
        tags (List[Any]): Tags (optional)
        tags_raw (List[Any]): TagsRaw (optional)
        task_id (str): when the evidence entry was fetched (optional)
        version (int): No description provided (optional)
        xsoar_has_read_only_role (bool): No description provided (optional)
        xsoar_previous_read_only_roles (List[Any]): No description provided (optional)
        xsoar_read_only_roles (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: The new / updated Evidence
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if shard_id is not None:
        body["ShardID"] = shard_id
    if all_read is not None:
        body["allRead"] = all_read
    if all_read_write is not None:
        body["allReadWrite"] = all_read_write
    if cache_versn is not None:
        body["cacheVersn"] = cache_versn
    if created is not None:
        body["created"] = created
    if dbot_created_by is not None:
        body["dbotCreatedBy"] = dbot_created_by
    if description is not None:
        body["description"] = description
    if entry_id is not None:
        body["entryId"] = entry_id
    if fetched is not None:
        body["fetched"] = fetched
    if has_role is not None:
        body["hasRole"] = has_role
    if highlight is not None:
        body["highlight"] = highlight
    if id is not None:
        body["id"] = id
    if incident_id is not None:
        body["incidentId"] = incident_id
    if index_name is not None:
        body["indexName"] = index_name
    if marked_by is not None:
        body["markedBy"] = marked_by
    if marked_date is not None:
        body["markedDate"] = marked_date
    if modified is not None:
        body["modified"] = modified
    if numeric_id is not None:
        body["numericId"] = numeric_id
    if occurred is not None:
        body["occurred"] = occurred
    if previous_all_read is not None:
        body["previousAllRead"] = previous_all_read
    if previous_all_read_write is not None:
        body["previousAllReadWrite"] = previous_all_read_write
    if previous_roles is not None:
        body["previousRoles"] = previous_roles
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if roles is not None:
        body["roles"] = roles
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if size_in_bytes is not None:
        body["sizeInBytes"] = size_in_bytes
    if sort_values is not None:
        body["sortValues"] = sort_values
    if sync_hash is not None:
        body["syncHash"] = sync_hash
    if tags is not None:
        body["tags"] = tags
    if tags_raw is not None:
        body["tagsRaw"] = tags_raw
    if task_id is not None:
        body["taskId"] = task_id
    if version is not None:
        body["version"] = version
    if xsoar_has_read_only_role is not None:
        body["xsoarHasReadOnlyRole"] = xsoar_has_read_only_role
    if xsoar_previous_read_only_roles is not None:
        body["xsoarPreviousReadOnlyRoles"] = xsoar_previous_read_only_roles
    if xsoar_read_only_roles is not None:
        body["xsoarReadOnlyRoles"] = xsoar_read_only_roles

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/evidence"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_evidence
xsoar_save_evidence_schema = {
    "type": "object",
    "properties": {
        "shard_id": {"type": "int", "description": ""},
        "all_read": {"type": "bool", "description": ""},
        "all_read_write": {"type": "bool", "description": ""},
        "cache_versn": {"type": "int", "description": ""},
        "created": {"type": "str", "description": ""},
        "dbot_created_by": {"type": "str", "description": "Who has created this event - relevant only for manual incidents"},
        "description": {"type": "str", "description": "The description for the resolve"},
        "entry_id": {"type": "str", "description": "The entry ID"},
        "fetched": {"type": "str", "description": "when the evidence entry was fetched"},
        "has_role": {"type": "bool", "description": "Internal field to make queries on role faster"},
        "highlight": {"type": "Dict[str, Any]", "description": ""},
        "id": {"type": "str", "description": ""},
        "incident_id": {"type": "str", "description": "The incident ID"},
        "index_name": {"type": "str", "description": ""},
        "marked_by": {"type": "str", "description": "the user that marked this evidence"},
        "marked_date": {"type": "str", "description": "when this evidence was marked"},
        "modified": {"type": "str", "description": ""},
        "numeric_id": {"type": "int", "description": ""},
        "occurred": {"type": "str", "description": "When this evidence has occurred"},
        "previous_all_read": {"type": "bool", "description": ""},
        "previous_all_read_write": {"type": "bool", "description": ""},
        "previous_roles": {"type": "List[Any]", "description": "Do not change this field manually"},
        "primary_term": {"type": "int", "description": ""},
        "roles": {"type": "List[Any]", "description": "The role assigned to this investigation"},
        "sequence_number": {"type": "int", "description": ""},
        "size_in_bytes": {"type": "int", "description": ""},
        "sort_values": {"type": "List[Any]", "description": ""},
        "sync_hash": {"type": "str", "description": ""},
        "tags": {"type": "List[Any]", "description": "Tags"},
        "tags_raw": {"type": "List[Any]", "description": "TagsRaw"},
        "task_id": {"type": "str", "description": "when the evidence entry was fetched"},
        "version": {"type": "int", "description": ""},
        "xsoar_has_read_only_role": {"type": "bool", "description": ""},
        "xsoar_previous_read_only_roles": {"type": "List[Any]", "description": ""},
        "xsoar_read_only_roles": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_delete_evidence_op(
    evidence_id: str | None = None,
) -> List[types.TextContent]:
    """
    Delete an evidence entity
    
    Args:
        evidence_id (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: Deleted evidence ID
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if evidence_id is not None:
        body["evidenceID"] = evidence_id

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/evidence/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_evidence_op
xsoar_delete_evidence_op_schema = {
    "type": "object",
    "properties": {
        "evidence_id": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_search_evidence(
    filter: str | None = None,
    incident_id: str | None = None,
) -> List[types.TextContent]:
    """
    Search for an evidence entutiy by filter
    
    Args:
        filter (str): No description provided (optional)
        incident_id (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: EvidencesSearchResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if filter is not None:
        body["filter"] = filter
    if incident_id is not None:
        body["incidentID"] = incident_id

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/evidence/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_evidence
xsoar_search_evidence_schema = {
    "type": "object",
    "properties": {
        "filter": {"type": "str", "description": ""},
        "incident_id": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_health_handler(

) -> List[types.TextContent]:
    """
    Check if Cortex XSOAR server is available
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: OK status
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/health"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_health_handler
xsoar_health_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_containers(

) -> List[types.TextContent]:
    """
    Gets info on the containers - amount of running, inactive and total containers
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Gets info on the containers - amount of running, inactive and total containers
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/health/containers"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_containers
xsoar_containers_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_incident(
    shard_id: int | None = None,
    account: str | None = None,
    activated: str | None = None,
    activatinging_user_id: str | None = None,
    all_read: bool | None = None,
    all_read_write: bool | None = None,
    autime: int | None = None,
    cache_versn: int | None = None,
    canvases: List[Any] | None = None,
    category: str | None = None,
    close_notes: str | None = None,
    close_reason: str | None = None,
    closed: str | None = None,
    closing_user_id: str | None = None,
    create_investigation: bool | None = None,
    created: str | None = None,
    dbot_created_by: str | None = None,
    dbot_current_dirty_fields: List[Any] | None = None,
    dbot_dirty_fields: List[Any] | None = None,
    dbot_mirror_direction: str | None = None,
    dbot_mirror_id: str | None = None,
    dbot_mirror_instance: str | None = None,
    dbot_mirror_last_sync: str | None = None,
    dbot_mirror_tags: List[Any] | None = None,
    details: str | None = None,
    dropped_count: int | None = None,
    due_date: str | None = None,
    feed_based: bool | None = None,
    has_role: bool | None = None,
    highlight: Dict[str, Any] | None = None,
    index_name: str | None = None,
    investigation_id: str | None = None,
    is_debug: bool | None = None,
    is_playground: bool | None = None,
    labels: List[Any] | None = None,
    last_job_run_time: str | None = None,
    last_open: str | None = None,
    linked_count: int | None = None,
    linked_incidents: List[Any] | None = None,
    modified: str | None = None,
    name: str | None = None,
    notify_time: str | None = None,
    numeric_id: int | None = None,
    occurred: str | None = None,
    open_duration: int | None = None,
    owner: str | None = None,
    parent: str | None = None,
    phase: str | None = None,
    playbook_id: str | None = None,
    previous_all_read: bool | None = None,
    previous_all_read_write: bool | None = None,
    previous_roles: List[Any] | None = None,
    primary_term: int | None = None,
    raw_category: str | None = None,
    raw_close_reason: str | None = None,
    raw_json: str | None = None,
    raw_name: str | None = None,
    raw_phase: str | None = None,
    raw_type: str | None = None,
    reason: str | None = None,
    reminder: str | None = None,
    roles: List[Any] | None = None,
    run_status: str | None = None,
    sequence_number: int | None = None,
    severity: str | None = None,
    size_in_bytes: int | None = None,
    sla: str | None = None,
    sort_values: List[Any] | None = None,
    source_brand: str | None = None,
    source_instance: str | None = None,
    status: str | None = None,
    sync_hash: str | None = None,
    todo_task_ids: List[Any] | None = None,
    type: str | None = None,
    version: int | None = None,
    xsoar_has_read_only_role: bool | None = None,
    xsoar_previous_read_only_roles: List[Any] | None = None,
    xsoar_read_only_roles: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Create or update incident according to JSON structure.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update

Use the 'createInvestigation\: true' to start the investigation process automatically. (by running a playbook based on incident type.)
    
    Args:
        shard_id (int): No description provided (optional)
        account (str): Account holds the tenant name so that slicing and dicing on the master can leverage bleve (optional)
        activated (str): When was this activated (optional)
        activatinging_user_id (str): The user that activated this investigation (optional)
        all_read (bool): No description provided (optional)
        all_read_write (bool): No description provided (optional)
        autime (int): AlmostUniqueTime is an attempt to have a unique sortable ID for an incident (optional)
        cache_versn (int): No description provided (optional)
        canvases (List[Any]): Canvases of the incident (optional)
        category (str): Category (optional)
        close_notes (str): Notes for closing the incident (optional)
        close_reason (str): The reason for closing the incident (select from existing predefined values) (optional)
        closed (str): When was this closed (optional)
        closing_user_id (str): The user ID that closed this investigation (optional)
        create_investigation (bool): No description provided (optional)
        created (str): No description provided (optional)
        dbot_created_by (str): Who has created this event - relevant only for manual incidents (optional)
        dbot_current_dirty_fields (List[Any]): For mirroring, manage a list of current dirty fields so that we can send delta to outgoing integration (optional)
        dbot_dirty_fields (List[Any]): For mirroring, manage a list of dirty fields to not override them from the source of the incident (optional)
        dbot_mirror_direction (str): DBotMirrorDirection of how to mirror the incident (in/out/both) (optional)
        dbot_mirror_id (str): DBotMirrorID of a remote system we are syncing with (optional)
        dbot_mirror_instance (str): DBotMirrorInstance name of a mirror integration instance (optional)
        dbot_mirror_last_sync (str): The last time we synced this incident even if we did not update anything (optional)
        dbot_mirror_tags (List[Any]): The entry tags I want to sync to remote system (optional)
        details (str): The details of the incident - reason, etc. (optional)
        dropped_count (int): DroppedCount ... (optional)
        due_date (str): SLA (optional)
        feed_based (bool): If this incident was triggered by a feed job (optional)
        has_role (bool): Internal field to make queries on role faster (optional)
        highlight (Dict[str, Any]): No description provided (optional)
        index_name (str): No description provided (optional)
        investigation_id (str): Investigation that was opened as a result of the incoming event (optional)
        is_debug (bool): IsDebug ... (optional)
        is_playground (bool): IsPlayGround (optional)
        labels (List[Any]): Labels related to incident - each label is composed of a type and value (optional)
        last_job_run_time (str): If this incident was triggered by a job, this would be the time the **previous** job started (optional)
        last_open (str): No description provided (optional)
        linked_count (int): LinkedCount ... (optional)
        linked_incidents (List[Any]): LinkedIncidents incidents that were marked as linked by user (optional)
        modified (str): No description provided (optional)
        name (str): Incident Name - given by user (optional)
        notify_time (str): Incdicates when last this field was changed with a value that supposed to send a notification (optional)
        numeric_id (int): No description provided (optional)
        occurred (str): When this incident has really occurred (optional)
        open_duration (int): Duration incident was open (optional)
        owner (str): The user who owns this incident (optional)
        parent (str): Parent (optional)
        phase (str): Phase (optional)
        playbook_id (str): The associated playbook for this incident (optional)
        previous_all_read (bool): No description provided (optional)
        previous_all_read_write (bool): No description provided (optional)
        previous_roles (List[Any]): Do not change this field manually (optional)
        primary_term (int): No description provided (optional)
        raw_category (str): No description provided (optional)
        raw_close_reason (str): The reason for closing the incident (select from existing predefined values) (optional)
        raw_json (str): No description provided (optional)
        raw_name (str): Incident RawName (optional)
        raw_phase (str): RawPhase (optional)
        raw_type (str): Incident raw type (optional)
        reason (str): The reason an incident was closed. (optional)
        reminder (str): When if at all to send a reminder (optional)
        roles (List[Any]): The role assigned to this investigation (optional)
        run_status (str): No description provided (optional)
        sequence_number (int): No description provided (optional)
        severity (str): No description provided (optional)
        size_in_bytes (int): No description provided (optional)
        sla (str): No description provided (optional)
        sort_values (List[Any]): No description provided (optional)
        source_brand (str): SourceBrand ... (optional)
        source_instance (str): SourceInstance ... (optional)
        status (str): No description provided (optional)
        sync_hash (str): No description provided (optional)
        todo_task_ids (List[Any]): ToDoTaskIDs list of to do task ids (optional)
        type (str): Incident type (optional)
        version (int): No description provided (optional)
        xsoar_has_read_only_role (bool): No description provided (optional)
        xsoar_previous_read_only_roles (List[Any]): No description provided (optional)
        xsoar_read_only_roles (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IncidentWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if shard_id is not None:
        body["ShardID"] = shard_id
    if account is not None:
        body["account"] = account
    if activated is not None:
        body["activated"] = activated
    if activatinging_user_id is not None:
        body["activatingingUserId"] = activatinging_user_id
    if all_read is not None:
        body["allRead"] = all_read
    if all_read_write is not None:
        body["allReadWrite"] = all_read_write
    if autime is not None:
        body["autime"] = autime
    if cache_versn is not None:
        body["cacheVersn"] = cache_versn
    if canvases is not None:
        body["canvases"] = canvases
    if category is not None:
        body["category"] = category
    if close_notes is not None:
        body["closeNotes"] = close_notes
    if close_reason is not None:
        body["closeReason"] = close_reason
    if closed is not None:
        body["closed"] = closed
    if closing_user_id is not None:
        body["closingUserId"] = closing_user_id
    if create_investigation is not None:
        body["createInvestigation"] = create_investigation
    if created is not None:
        body["created"] = created
    if dbot_created_by is not None:
        body["dbotCreatedBy"] = dbot_created_by
    if dbot_current_dirty_fields is not None:
        body["dbotCurrentDirtyFields"] = dbot_current_dirty_fields
    if dbot_dirty_fields is not None:
        body["dbotDirtyFields"] = dbot_dirty_fields
    if dbot_mirror_direction is not None:
        body["dbotMirrorDirection"] = dbot_mirror_direction
    if dbot_mirror_id is not None:
        body["dbotMirrorId"] = dbot_mirror_id
    if dbot_mirror_instance is not None:
        body["dbotMirrorInstance"] = dbot_mirror_instance
    if dbot_mirror_last_sync is not None:
        body["dbotMirrorLastSync"] = dbot_mirror_last_sync
    if dbot_mirror_tags is not None:
        body["dbotMirrorTags"] = dbot_mirror_tags
    if details is not None:
        body["details"] = details
    if dropped_count is not None:
        body["droppedCount"] = dropped_count
    if due_date is not None:
        body["dueDate"] = due_date
    if feed_based is not None:
        body["feedBased"] = feed_based
    if has_role is not None:
        body["hasRole"] = has_role
    if highlight is not None:
        body["highlight"] = highlight
    if index_name is not None:
        body["indexName"] = index_name
    if investigation_id is not None:
        body["investigationId"] = investigation_id
    if is_debug is not None:
        body["isDebug"] = is_debug
    if is_playground is not None:
        body["isPlayground"] = is_playground
    if labels is not None:
        body["labels"] = labels
    if last_job_run_time is not None:
        body["lastJobRunTime"] = last_job_run_time
    if last_open is not None:
        body["lastOpen"] = last_open
    if linked_count is not None:
        body["linkedCount"] = linked_count
    if linked_incidents is not None:
        body["linkedIncidents"] = linked_incidents
    if modified is not None:
        body["modified"] = modified
    if name is not None:
        body["name"] = name
    if notify_time is not None:
        body["notifyTime"] = notify_time
    if numeric_id is not None:
        body["numericId"] = numeric_id
    if occurred is not None:
        body["occurred"] = occurred
    if open_duration is not None:
        body["openDuration"] = open_duration
    if owner is not None:
        body["owner"] = owner
    if parent is not None:
        body["parent"] = parent
    if phase is not None:
        body["phase"] = phase
    if playbook_id is not None:
        body["playbookId"] = playbook_id
    if previous_all_read is not None:
        body["previousAllRead"] = previous_all_read
    if previous_all_read_write is not None:
        body["previousAllReadWrite"] = previous_all_read_write
    if previous_roles is not None:
        body["previousRoles"] = previous_roles
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if raw_category is not None:
        body["rawCategory"] = raw_category
    if raw_close_reason is not None:
        body["rawCloseReason"] = raw_close_reason
    if raw_json is not None:
        body["rawJSON"] = raw_json
    if raw_name is not None:
        body["rawName"] = raw_name
    if raw_phase is not None:
        body["rawPhase"] = raw_phase
    if raw_type is not None:
        body["rawType"] = raw_type
    if reason is not None:
        body["reason"] = reason
    if reminder is not None:
        body["reminder"] = reminder
    if roles is not None:
        body["roles"] = roles
    if run_status is not None:
        body["runStatus"] = run_status
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if severity is not None:
        body["severity"] = severity
    if size_in_bytes is not None:
        body["sizeInBytes"] = size_in_bytes
    if sla is not None:
        body["sla"] = sla
    if sort_values is not None:
        body["sortValues"] = sort_values
    if source_brand is not None:
        body["sourceBrand"] = source_brand
    if source_instance is not None:
        body["sourceInstance"] = source_instance
    if status is not None:
        body["status"] = status
    if sync_hash is not None:
        body["syncHash"] = sync_hash
    if todo_task_ids is not None:
        body["todoTaskIds"] = todo_task_ids
    if type is not None:
        body["type"] = type
    if version is not None:
        body["version"] = version
    if xsoar_has_read_only_role is not None:
        body["xsoarHasReadOnlyRole"] = xsoar_has_read_only_role
    if xsoar_previous_read_only_roles is not None:
        body["xsoarPreviousReadOnlyRoles"] = xsoar_previous_read_only_roles
    if xsoar_read_only_roles is not None:
        body["xsoarReadOnlyRoles"] = xsoar_read_only_roles

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incident
xsoar_create_incident_schema = {
    "type": "object",
    "properties": {
        "shard_id": {"type": "int", "description": ""},
        "account": {"type": "str", "description": "Account holds the tenant name so that slicing and dicing on the master can leverage bleve"},
        "activated": {"type": "str", "description": "When was this activated"},
        "activatinging_user_id": {"type": "str", "description": "The user that activated this investigation"},
        "all_read": {"type": "bool", "description": ""},
        "all_read_write": {"type": "bool", "description": ""},
        "autime": {"type": "int", "description": "AlmostUniqueTime is an attempt to have a unique sortable ID for an incident"},
        "cache_versn": {"type": "int", "description": ""},
        "canvases": {"type": "List[Any]", "description": "Canvases of the incident"},
        "category": {"type": "str", "description": "Category"},
        "close_notes": {"type": "str", "description": "Notes for closing the incident"},
        "close_reason": {"type": "str", "description": "The reason for closing the incident (select from existing predefined values)"},
        "closed": {"type": "str", "description": "When was this closed"},
        "closing_user_id": {"type": "str", "description": "The user ID that closed this investigation"},
        "create_investigation": {"type": "bool", "description": ""},
        "created": {"type": "str", "description": ""},
        "dbot_created_by": {"type": "str", "description": "Who has created this event - relevant only for manual incidents"},
        "dbot_current_dirty_fields": {"type": "List[Any]", "description": "For mirroring, manage a list of current dirty fields so that we can send delta to outgoing integration"},
        "dbot_dirty_fields": {"type": "List[Any]", "description": "For mirroring, manage a list of dirty fields to not override them from the source of the incident"},
        "dbot_mirror_direction": {"type": "str", "description": "DBotMirrorDirection of how to mirror the incident (in/out/both)"},
        "dbot_mirror_id": {"type": "str", "description": "DBotMirrorID of a remote system we are syncing with"},
        "dbot_mirror_instance": {"type": "str", "description": "DBotMirrorInstance name of a mirror integration instance"},
        "dbot_mirror_last_sync": {"type": "str", "description": "The last time we synced this incident even if we did not update anything"},
        "dbot_mirror_tags": {"type": "List[Any]", "description": "The entry tags I want to sync to remote system"},
        "details": {"type": "str", "description": "The details of the incident - reason, etc."},
        "dropped_count": {"type": "int", "description": "DroppedCount ..."},
        "due_date": {"type": "str", "description": "SLA"},
        "feed_based": {"type": "bool", "description": "If this incident was triggered by a feed job"},
        "has_role": {"type": "bool", "description": "Internal field to make queries on role faster"},
        "highlight": {"type": "Dict[str, Any]", "description": ""},
        "index_name": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": "Investigation that was opened as a result of the incoming event"},
        "is_debug": {"type": "bool", "description": "IsDebug ..."},
        "is_playground": {"type": "bool", "description": "IsPlayGround"},
        "labels": {"type": "List[Any]", "description": "Labels related to incident - each label is composed of a type and value"},
        "last_job_run_time": {"type": "str", "description": "If this incident was triggered by a job, this would be the time the **previous** job started"},
        "last_open": {"type": "str", "description": ""},
        "linked_count": {"type": "int", "description": "LinkedCount ..."},
        "linked_incidents": {"type": "List[Any]", "description": "LinkedIncidents incidents that were marked as linked by user"},
        "modified": {"type": "str", "description": ""},
        "name": {"type": "str", "description": "Incident Name - given by user"},
        "notify_time": {"type": "str", "description": "Incdicates when last this field was changed with a value that supposed to send a notification"},
        "numeric_id": {"type": "int", "description": ""},
        "occurred": {"type": "str", "description": "When this incident has really occurred"},
        "open_duration": {"type": "int", "description": "Duration incident was open"},
        "owner": {"type": "str", "description": "The user who owns this incident"},
        "parent": {"type": "str", "description": "Parent"},
        "phase": {"type": "str", "description": "Phase"},
        "playbook_id": {"type": "str", "description": "The associated playbook for this incident"},
        "previous_all_read": {"type": "bool", "description": ""},
        "previous_all_read_write": {"type": "bool", "description": ""},
        "previous_roles": {"type": "List[Any]", "description": "Do not change this field manually"},
        "primary_term": {"type": "int", "description": ""},
        "raw_category": {"type": "str", "description": ""},
        "raw_close_reason": {"type": "str", "description": "The reason for closing the incident (select from existing predefined values)"},
        "raw_json": {"type": "str", "description": ""},
        "raw_name": {"type": "str", "description": "Incident RawName"},
        "raw_phase": {"type": "str", "description": "RawPhase"},
        "raw_type": {"type": "str", "description": "Incident raw type"},
        "reason": {"type": "str", "description": "The reason an incident was closed."},
        "reminder": {"type": "str", "description": "When if at all to send a reminder"},
        "roles": {"type": "List[Any]", "description": "The role assigned to this investigation"},
        "run_status": {"type": "str", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "severity": {"type": "str", "description": ""},
        "size_in_bytes": {"type": "int", "description": ""},
        "sla": {"type": "str", "description": ""},
        "sort_values": {"type": "List[Any]", "description": ""},
        "source_brand": {"type": "str", "description": "SourceBrand ..."},
        "source_instance": {"type": "str", "description": "SourceInstance ..."},
        "status": {"type": "str", "description": ""},
        "sync_hash": {"type": "str", "description": ""},
        "todo_task_ids": {"type": "List[Any]", "description": "ToDoTaskIDs list of to do task ids"},
        "type": {"type": "str", "description": "Incident type"},
        "version": {"type": "int", "description": ""},
        "xsoar_has_read_only_role": {"type": "bool", "description": ""},
        "xsoar_previous_read_only_roles": {"type": "List[Any]", "description": ""},
        "xsoar_read_only_roles": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_create_incidents_batch(
    custom_fields: Dict[str, Any] | None = None,
    all: bool | None = None,
    close_notes: str | None = None,
    close_reason: str | None = None,
    columns: List[Any] | None = None,
    data: Dict[str, Any] | None = None,
    filter: str | None = None,
    force: bool | None = None,
    ids: List[Any] | None = None,
    line: str | None = None,
    original_incident_id: str | None = None,
    override_investigation: bool | None = None,
) -> List[types.TextContent]:
    """
    Update a batch of incidents.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        custom_fields (Dict[str, Any]): No description provided (optional)
        all (bool): No description provided (optional)
        close_notes (str): No description provided (optional)
        close_reason (str): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        data (Dict[str, Any]): No description provided (optional)
        filter (str): No description provided (optional)
        force (bool): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        line (str): No description provided (optional)
        original_incident_id (str): No description provided (optional)
        override_investigation (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: 
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if custom_fields is not None:
        body["CustomFields"] = custom_fields
    if all is not None:
        body["all"] = all
    if close_notes is not None:
        body["closeNotes"] = close_notes
    if close_reason is not None:
        body["closeReason"] = close_reason
    if columns is not None:
        body["columns"] = columns
    if data is not None:
        body["data"] = data
    if filter is not None:
        body["filter"] = filter
    if force is not None:
        body["force"] = force
    if ids is not None:
        body["ids"] = ids
    if line is not None:
        body["line"] = line
    if original_incident_id is not None:
        body["originalIncidentId"] = original_incident_id
    if override_investigation is not None:
        body["overrideInvestigation"] = override_investigation

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batch"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incidents_batch
xsoar_create_incidents_batch_schema = {
    "type": "object",
    "properties": {
        "custom_fields": {"type": "Dict[str, Any]", "description": ""},
        "all": {"type": "bool", "description": ""},
        "close_notes": {"type": "str", "description": ""},
        "close_reason": {"type": "str", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "data": {"type": "Dict[str, Any]", "description": ""},
        "filter": {"type": "str", "description": ""},
        "force": {"type": "bool", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "line": {"type": "str", "description": ""},
        "original_incident_id": {"type": "str", "description": ""},
        "override_investigation": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_export_incidents_to_csv_batch(
    custom_fields: Dict[str, Any] | None = None,
    all: bool | None = None,
    close_notes: str | None = None,
    close_reason: str | None = None,
    columns: List[Any] | None = None,
    data: Dict[str, Any] | None = None,
    filter: str | None = None,
    force: bool | None = None,
    ids: List[Any] | None = None,
    line: str | None = None,
    original_incident_id: str | None = None,
    override_investigation: bool | None = None,
) -> List[types.TextContent]:
    """
    Exports an incidents batch to CSV file (returns file ID)
    
    Args:
        custom_fields (Dict[str, Any]): No description provided (optional)
        all (bool): No description provided (optional)
        close_notes (str): No description provided (optional)
        close_reason (str): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        data (Dict[str, Any]): No description provided (optional)
        filter (str): No description provided (optional)
        force (bool): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        line (str): No description provided (optional)
        original_incident_id (str): No description provided (optional)
        override_investigation (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: csv file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if custom_fields is not None:
        body["CustomFields"] = custom_fields
    if all is not None:
        body["all"] = all
    if close_notes is not None:
        body["closeNotes"] = close_notes
    if close_reason is not None:
        body["closeReason"] = close_reason
    if columns is not None:
        body["columns"] = columns
    if data is not None:
        body["data"] = data
    if filter is not None:
        body["filter"] = filter
    if force is not None:
        body["force"] = force
    if ids is not None:
        body["ids"] = ids
    if line is not None:
        body["line"] = line
    if original_incident_id is not None:
        body["originalIncidentId"] = original_incident_id
    if override_investigation is not None:
        body["overrideInvestigation"] = override_investigation

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_incidents_to_csv_batch
xsoar_export_incidents_to_csv_batch_schema = {
    "type": "object",
    "properties": {
        "custom_fields": {"type": "Dict[str, Any]", "description": ""},
        "all": {"type": "bool", "description": ""},
        "close_notes": {"type": "str", "description": ""},
        "close_reason": {"type": "str", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "data": {"type": "Dict[str, Any]", "description": ""},
        "filter": {"type": "str", "description": ""},
        "force": {"type": "bool", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "line": {"type": "str", "description": ""},
        "original_incident_id": {"type": "str", "description": ""},
        "override_investigation": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_close_incidents_batch(
    custom_fields: Dict[str, Any] | None = None,
    all: bool | None = None,
    close_notes: str | None = None,
    close_reason: str | None = None,
    columns: List[Any] | None = None,
    data: Dict[str, Any] | None = None,
    filter: str | None = None,
    force: bool | None = None,
    ids: List[Any] | None = None,
    line: str | None = None,
    original_incident_id: str | None = None,
    override_investigation: bool | None = None,
) -> List[types.TextContent]:
    """
    Closes an incidents batch
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        custom_fields (Dict[str, Any]): No description provided (optional)
        all (bool): No description provided (optional)
        close_notes (str): No description provided (optional)
        close_reason (str): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        data (Dict[str, Any]): No description provided (optional)
        filter (str): No description provided (optional)
        force (bool): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        line (str): No description provided (optional)
        original_incident_id (str): No description provided (optional)
        override_investigation (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IncidentSearchResponseWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if custom_fields is not None:
        body["CustomFields"] = custom_fields
    if all is not None:
        body["all"] = all
    if close_notes is not None:
        body["closeNotes"] = close_notes
    if close_reason is not None:
        body["closeReason"] = close_reason
    if columns is not None:
        body["columns"] = columns
    if data is not None:
        body["data"] = data
    if filter is not None:
        body["filter"] = filter
    if force is not None:
        body["force"] = force
    if ids is not None:
        body["ids"] = ids
    if line is not None:
        body["line"] = line
    if original_incident_id is not None:
        body["originalIncidentId"] = original_incident_id
    if override_investigation is not None:
        body["overrideInvestigation"] = override_investigation

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batchClose"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_close_incidents_batch
xsoar_close_incidents_batch_schema = {
    "type": "object",
    "properties": {
        "custom_fields": {"type": "Dict[str, Any]", "description": ""},
        "all": {"type": "bool", "description": ""},
        "close_notes": {"type": "str", "description": ""},
        "close_reason": {"type": "str", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "data": {"type": "Dict[str, Any]", "description": ""},
        "filter": {"type": "str", "description": ""},
        "force": {"type": "bool", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "line": {"type": "str", "description": ""},
        "original_incident_id": {"type": "str", "description": ""},
        "override_investigation": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_delete_incidents_batch(
    custom_fields: Dict[str, Any] | None = None,
    all: bool | None = None,
    close_notes: str | None = None,
    close_reason: str | None = None,
    columns: List[Any] | None = None,
    data: Dict[str, Any] | None = None,
    filter: str | None = None,
    force: bool | None = None,
    ids: List[Any] | None = None,
    line: str | None = None,
    original_incident_id: str | None = None,
    override_investigation: bool | None = None,
) -> List[types.TextContent]:
    """
    Deletes an incidents batch
    
    Args:
        custom_fields (Dict[str, Any]): No description provided (optional)
        all (bool): No description provided (optional)
        close_notes (str): No description provided (optional)
        close_reason (str): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        data (Dict[str, Any]): No description provided (optional)
        filter (str): No description provided (optional)
        force (bool): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        line (str): No description provided (optional)
        original_incident_id (str): No description provided (optional)
        override_investigation (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IncidentSearchResponseWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if custom_fields is not None:
        body["CustomFields"] = custom_fields
    if all is not None:
        body["all"] = all
    if close_notes is not None:
        body["closeNotes"] = close_notes
    if close_reason is not None:
        body["closeReason"] = close_reason
    if columns is not None:
        body["columns"] = columns
    if data is not None:
        body["data"] = data
    if filter is not None:
        body["filter"] = filter
    if force is not None:
        body["force"] = force
    if ids is not None:
        body["ids"] = ids
    if line is not None:
        body["line"] = line
    if original_incident_id is not None:
        body["originalIncidentId"] = original_incident_id
    if override_investigation is not None:
        body["overrideInvestigation"] = override_investigation

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_incidents_batch
xsoar_delete_incidents_batch_schema = {
    "type": "object",
    "properties": {
        "custom_fields": {"type": "Dict[str, Any]", "description": ""},
        "all": {"type": "bool", "description": ""},
        "close_notes": {"type": "str", "description": ""},
        "close_reason": {"type": "str", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "data": {"type": "Dict[str, Any]", "description": ""},
        "filter": {"type": "str", "description": ""},
        "force": {"type": "bool", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "line": {"type": "str", "description": ""},
        "original_incident_id": {"type": "str", "description": ""},
        "override_investigation": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_incident_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an incident CSV file that was exported, by ID
    
    Args:
        id (str): CSV file to fetch (returned from batch export to csv call) (required)
    
    Returns:
        List[types.TextContent]: Return Csv file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incident_as_csv
xsoar_incident_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def xsoar_create_incident_json(

) -> List[types.TextContent]:
    """
    Create single incident from raw JSON, builds incident according to default mapping
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Created
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incident_json
xsoar_create_incident_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_incident_file_upload(
    id: str,
) -> List[types.TextContent]:
    """
    Add file attachement to an incidents
    
    Args:
        id (str): Incident id to update (required)
    
    Returns:
        List[types.TextContent]: IncidentWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/upload/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incident_file_upload
xsoar_incident_file_upload_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Incident id to update"},
    },
}

@server.call_tool()
async def xsoar_set_tags_field(
    id: str,
    data: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Sets the select values of a specific tags field. The values passed to the route override the existing select
values of the field. To reset the select values pass an empty array.
    
    Args:
        id (str): The machine name of the field prefixed with the type. For example indicator_tags or incident_dbotmirrortags (required)
        data (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: empty
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if data is not None:
        body["data"] = data
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidentfield/tags/reset/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_set_tags_field
xsoar_set_tags_field_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The machine name of the field prefixed with the type. For example indicator_tags or incident_dbotmirrortags"},
        "data": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_incidents_fields_by_incident_type(
    type: str,
) -> List[types.TextContent]:
    """
    Get all incident fields associated with incident type
    
    Args:
        type (str): the name (case sensitive) of the incident type (required)
    
    Returns:
        List[types.TextContent]: Returns a list of incident fields associated with the incident type
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if type is not None:
        path_params["type"] = sanitize_input(type)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidentfields/associatedTypes/{type}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incidents_fields_by_incident_type
xsoar_incidents_fields_by_incident_type_schema = {
    "type": "object",
    "properties": {
        "type": {"type": "str", "description": "the name (case sensitive) of the incident type"},
    },
}

@server.call_tool()
async def xsoar_import_incident_fields(

) -> List[types.TextContent]:
    """
    Import an incident field to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved incident field
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidentfields/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_incident_fields
xsoar_import_incident_fields_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_incidents(
    filter: str | None = None,
    user_filter: bool | None = None,
) -> List[types.TextContent]:
    """
    Search incidents across all indices. You can filter by multiple options.

**Note:** You cannot paginate results in a multi-tenant environment.
    
    Args:
        filter (str): No description provided (optional)
        user_filter (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: incidentSearchResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if filter is not None:
        body["filter"] = filter
    if user_filter is not None:
        body["userFilter"] = user_filter

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidents/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_incidents
xsoar_search_incidents_schema = {
    "type": "object",
    "properties": {
        "filter": {"type": "str", "description": ""},
        "user_filter": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_create_or_update_incident_type(
    autorun: bool | None = None,
    cache_versn: int | None = None,
    closure_script: str | None = None,
    color: str | None = None,
    commit_message: str | None = None,
    created: str | None = None,
    days: int | None = None,
    days_r: int | None = None,
    default: bool | None = None,
    definition_id: str | None = None,
    detached: bool | None = None,
    disabled: bool | None = None,
    extract_settings: str | None = None,
    from_server_version: str | None = None,
    highlight: Dict[str, Any] | None = None,
    hours: int | None = None,
    hours_r: int | None = None,
    id: str | None = None,
    index_name: str | None = None,
    item_version: str | None = None,
    layout: str | None = None,
    locked: bool | None = None,
    modified: str | None = None,
    name: str | None = None,
    numeric_id: int | None = None,
    on_change_rep_alg: str | None = None,
    pack_id: str | None = None,
    pack_name: str | None = None,
    pack_propagation_labels: List[Any] | None = None,
    playbook_id: str | None = None,
    pre_processing_script: str | None = None,
    prev_name: str | None = None,
    primary_term: int | None = None,
    propagation_labels: List[Any] | None = None,
    readonly: bool | None = None,
    remote: bool | None = None,
    reputation_calc: str | None = None,
    sequence_number: int | None = None,
    should_commit: bool | None = None,
    size_in_bytes: int | None = None,
    sla: int | None = None,
    sla_reminder: int | None = None,
    sort_values: List[Any] | None = None,
    sync_hash: str | None = None,
    system: bool | None = None,
    to_server_version: str | None = None,
    vc_should_ignore: bool | None = None,
    vc_should_keep_item_legacy_prod_machine: bool | None = None,
    version: int | None = None,
    weeks: int | None = None,
    weeks_r: int | None = None,
) -> List[types.TextContent]:
    """
    API to create new Incident Type
    
    Args:
        autorun (bool): No description provided (optional)
        cache_versn (int): No description provided (optional)
        closure_script (str): No description provided (optional)
        color (str): No description provided (optional)
        commit_message (str): No description provided (optional)
        created (str): No description provided (optional)
        days (int): No description provided (optional)
        days_r (int): No description provided (optional)
        default (bool): No description provided (optional)
        definition_id (str): No description provided (optional)
        detached (bool): No description provided (optional)
        disabled (bool): No description provided (optional)
        extract_settings (str): No description provided (optional)
        from_server_version (str): No description provided (optional)
        highlight (Dict[str, Any]): No description provided (optional)
        hours (int): No description provided (optional)
        hours_r (int): No description provided (optional)
        id (str): No description provided (optional)
        index_name (str): No description provided (optional)
        item_version (str): No description provided (optional)
        layout (str): No description provided (optional)
        locked (bool): No description provided (optional)
        modified (str): No description provided (optional)
        name (str): No description provided (optional)
        numeric_id (int): No description provided (optional)
        on_change_rep_alg (str): No description provided (optional)
        pack_id (str): No description provided (optional)
        pack_name (str): No description provided (optional)
        pack_propagation_labels (List[Any]): No description provided (optional)
        playbook_id (str): No description provided (optional)
        pre_processing_script (str): No description provided (optional)
        prev_name (str): No description provided (optional)
        primary_term (int): No description provided (optional)
        propagation_labels (List[Any]): No description provided (optional)
        readonly (bool): No description provided (optional)
        remote (bool): No description provided (optional)
        reputation_calc (str): No description provided (optional)
        sequence_number (int): No description provided (optional)
        should_commit (bool): No description provided (optional)
        size_in_bytes (int): No description provided (optional)
        sla (int): No description provided (optional)
        sla_reminder (int): No description provided (optional)
        sort_values (List[Any]): No description provided (optional)
        sync_hash (str): No description provided (optional)
        system (bool): No description provided (optional)
        to_server_version (str): No description provided (optional)
        vc_should_ignore (bool): No description provided (optional)
        vc_should_keep_item_legacy_prod_machine (bool): No description provided (optional)
        version (int): No description provided (optional)
        weeks (int): No description provided (optional)
        weeks_r (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IncidentType
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if autorun is not None:
        body["autorun"] = autorun
    if cache_versn is not None:
        body["cacheVersn"] = cache_versn
    if closure_script is not None:
        body["closureScript"] = closure_script
    if color is not None:
        body["color"] = color
    if commit_message is not None:
        body["commitMessage"] = commit_message
    if created is not None:
        body["created"] = created
    if days is not None:
        body["days"] = days
    if days_r is not None:
        body["daysR"] = days_r
    if default is not None:
        body["default"] = default
    if definition_id is not None:
        body["definitionId"] = definition_id
    if detached is not None:
        body["detached"] = detached
    if disabled is not None:
        body["disabled"] = disabled
    if extract_settings is not None:
        body["extractSettings"] = extract_settings
    if from_server_version is not None:
        body["fromServerVersion"] = from_server_version
    if highlight is not None:
        body["highlight"] = highlight
    if hours is not None:
        body["hours"] = hours
    if hours_r is not None:
        body["hoursR"] = hours_r
    if id is not None:
        body["id"] = id
    if index_name is not None:
        body["indexName"] = index_name
    if item_version is not None:
        body["itemVersion"] = item_version
    if layout is not None:
        body["layout"] = layout
    if locked is not None:
        body["locked"] = locked
    if modified is not None:
        body["modified"] = modified
    if name is not None:
        body["name"] = name
    if numeric_id is not None:
        body["numericId"] = numeric_id
    if on_change_rep_alg is not None:
        body["onChangeRepAlg"] = on_change_rep_alg
    if pack_id is not None:
        body["packID"] = pack_id
    if pack_name is not None:
        body["packName"] = pack_name
    if pack_propagation_labels is not None:
        body["packPropagationLabels"] = pack_propagation_labels
    if playbook_id is not None:
        body["playbookId"] = playbook_id
    if pre_processing_script is not None:
        body["preProcessingScript"] = pre_processing_script
    if prev_name is not None:
        body["prevName"] = prev_name
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if propagation_labels is not None:
        body["propagationLabels"] = propagation_labels
    if readonly is not None:
        body["readonly"] = readonly
    if remote is not None:
        body["remote"] = remote
    if reputation_calc is not None:
        body["reputationCalc"] = reputation_calc
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if should_commit is not None:
        body["shouldCommit"] = should_commit
    if size_in_bytes is not None:
        body["sizeInBytes"] = size_in_bytes
    if sla is not None:
        body["sla"] = sla
    if sla_reminder is not None:
        body["slaReminder"] = sla_reminder
    if sort_values is not None:
        body["sortValues"] = sort_values
    if sync_hash is not None:
        body["syncHash"] = sync_hash
    if system is not None:
        body["system"] = system
    if to_server_version is not None:
        body["toServerVersion"] = to_server_version
    if vc_should_ignore is not None:
        body["vcShouldIgnore"] = vc_should_ignore
    if vc_should_keep_item_legacy_prod_machine is not None:
        body["vcShouldKeepItemLegacyProdMachine"] = vc_should_keep_item_legacy_prod_machine
    if version is not None:
        body["version"] = version
    if weeks is not None:
        body["weeks"] = weeks
    if weeks_r is not None:
        body["weeksR"] = weeks_r

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidenttype"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_or_update_incident_type
xsoar_create_or_update_incident_type_schema = {
    "type": "object",
    "properties": {
        "autorun": {"type": "bool", "description": ""},
        "cache_versn": {"type": "int", "description": ""},
        "closure_script": {"type": "str", "description": ""},
        "color": {"type": "str", "description": ""},
        "commit_message": {"type": "str", "description": ""},
        "created": {"type": "str", "description": ""},
        "days": {"type": "int", "description": ""},
        "days_r": {"type": "int", "description": ""},
        "default": {"type": "bool", "description": ""},
        "definition_id": {"type": "str", "description": ""},
        "detached": {"type": "bool", "description": ""},
        "disabled": {"type": "bool", "description": ""},
        "extract_settings": {"type": "str", "description": ""},
        "from_server_version": {"type": "str", "description": ""},
        "highlight": {"type": "Dict[str, Any]", "description": ""},
        "hours": {"type": "int", "description": ""},
        "hours_r": {"type": "int", "description": ""},
        "id": {"type": "str", "description": ""},
        "index_name": {"type": "str", "description": ""},
        "item_version": {"type": "str", "description": ""},
        "layout": {"type": "str", "description": ""},
        "locked": {"type": "bool", "description": ""},
        "modified": {"type": "str", "description": ""},
        "name": {"type": "str", "description": ""},
        "numeric_id": {"type": "int", "description": ""},
        "on_change_rep_alg": {"type": "str", "description": ""},
        "pack_id": {"type": "str", "description": ""},
        "pack_name": {"type": "str", "description": ""},
        "pack_propagation_labels": {"type": "List[Any]", "description": ""},
        "playbook_id": {"type": "str", "description": ""},
        "pre_processing_script": {"type": "str", "description": ""},
        "prev_name": {"type": "str", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "propagation_labels": {"type": "List[Any]", "description": ""},
        "readonly": {"type": "bool", "description": ""},
        "remote": {"type": "bool", "description": ""},
        "reputation_calc": {"type": "str", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "should_commit": {"type": "bool", "description": ""},
        "size_in_bytes": {"type": "int", "description": ""},
        "sla": {"type": "int", "description": ""},
        "sla_reminder": {"type": "int", "description": ""},
        "sort_values": {"type": "List[Any]", "description": ""},
        "sync_hash": {"type": "str", "description": ""},
        "system": {"type": "bool", "description": ""},
        "to_server_version": {"type": "str", "description": ""},
        "vc_should_ignore": {"type": "bool", "description": ""},
        "vc_should_keep_item_legacy_prod_machine": {"type": "bool", "description": ""},
        "version": {"type": "int", "description": ""},
        "weeks": {"type": "int", "description": ""},
        "weeks_r": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_import_incident_types_handler(

) -> List[types.TextContent]:
    """
    Import an incident type to Cortex XSOAR.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved incident type
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidenttypes/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_incident_types_handler
xsoar_import_incident_types_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_create(
    entry_id: str | None = None,
    indicator: str | None = None,
    investigation_id: str | None = None,
    manually: bool | None = None,
    seen_now: bool | None = None,
) -> List[types.TextContent]:
    """
    Create an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        entry_id (str): No description provided (optional)
        indicator (str): No description provided (optional)
        investigation_id (str): No description provided (optional)
        manually (bool): No description provided (optional)
        seen_now (bool): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IocObject
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if entry_id is not None:
        body["entryId"] = entry_id
    if indicator is not None:
        body["indicator"] = indicator
    if investigation_id is not None:
        body["investigationId"] = investigation_id
    if manually is not None:
        body["manually"] = manually
    if seen_now is not None:
        body["seenNow"] = seen_now

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicator/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_create
xsoar_indicators_create_schema = {
    "type": "object",
    "properties": {
        "entry_id": {"type": "str", "description": ""},
        "indicator": {"type": "str", "description": ""},
        "investigation_id": {"type": "str", "description": ""},
        "manually": {"type": "bool", "description": ""},
        "seen_now": {"type": "bool", "description": ""},
    },
}

@server.call_tool()
async def xsoar_indicators_edit(
    custom_fields: str | None = None,
    account: str | None = None,
    aggregated_reliability: str | None = None,
    cache_versn: int | None = None,
    calculated_time: str | None = None,
    comment: str | None = None,
    comments: str | None = None,
    created: str | None = None,
    deleted_feed_fetch_time: str | None = None,
    expiration: str | None = None,
    expiration_source: str | None = None,
    expiration_status: str | None = None,
    first_seen: str | None = None,
    first_seen_entry_id: str | None = None,
    highlight: Dict[str, Any] | None = None,
    id: str | None = None,
    index_name: str | None = None,
    indicator_type: str | None = None,
    insight_cache: str | None = None,
    investigation_i_ds: List[Any] | None = None,
    is_detectable: bool | None = None,
    is_preventable: bool | None = None,
    is_shared: bool | None = None,
    last_reputation_run: str | None = None,
    last_seen: str | None = None,
    last_seen_entry_id: str | None = None,
    manual_expiration_time: str | None = None,
    manual_score: bool | None = None,
    manual_set_time: str | None = None,
    manually_edited_fields: List[Any] | None = None,
    modified: str | None = None,
    modified_time: str | None = None,
    module_to_feed_map: Dict[str, Any] | None = None,
    numeric_id: int | None = None,
    primary_term: int | None = None,
    related_inc_count: int | None = None,
    score: int | None = None,
    sequence_number: int | None = None,
    set_by: str | None = None,
    size_in_bytes: int | None = None,
    sort_values: List[Any] | None = None,
    source: str | None = None,
    source_brands: List[Any] | None = None,
    source_instances: List[Any] | None = None,
    sync_hash: str | None = None,
    timestamp: str | None = None,
    value: str | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Edit an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        custom_fields (str): No description provided (optional)
        account (str): No description provided (optional)
        aggregated_reliability (str): No description provided (optional)
        cache_versn (int): No description provided (optional)
        calculated_time (str): Do not set the fields bellow this line (optional)
        comment (str): No description provided (optional)
        comments (str): No description provided (optional)
        created (str): No description provided (optional)
        deleted_feed_fetch_time (str): No description provided (optional)
        expiration (str): No description provided (optional)
        expiration_source (str): No description provided (optional)
        expiration_status (str): No description provided (optional)
        first_seen (str): No description provided (optional)
        first_seen_entry_id (str): No description provided (optional)
        highlight (Dict[str, Any]): No description provided (optional)
        id (str): No description provided (optional)
        index_name (str): No description provided (optional)
        indicator_type (str): No description provided (optional)
        insight_cache (str): No description provided (optional)
        investigation_i_ds (List[Any]): No description provided (optional)
        is_detectable (bool): No description provided (optional)
        is_preventable (bool): No description provided (optional)
        is_shared (bool): No description provided (optional)
        last_reputation_run (str): No description provided (optional)
        last_seen (str): No description provided (optional)
        last_seen_entry_id (str): No description provided (optional)
        manual_expiration_time (str): No description provided (optional)
        manual_score (bool): No description provided (optional)
        manual_set_time (str): No description provided (optional)
        manually_edited_fields (List[Any]): No description provided (optional)
        modified (str): No description provided (optional)
        modified_time (str): No description provided (optional)
        module_to_feed_map (Dict[str, Any]): No description provided (optional)
        numeric_id (int): No description provided (optional)
        primary_term (int): No description provided (optional)
        related_inc_count (int): No description provided (optional)
        score (int): No description provided (optional)
        sequence_number (int): No description provided (optional)
        set_by (str): No description provided (optional)
        size_in_bytes (int): No description provided (optional)
        sort_values (List[Any]): No description provided (optional)
        source (str): No description provided (optional)
        source_brands (List[Any]): No description provided (optional)
        source_instances (List[Any]): No description provided (optional)
        sync_hash (str): No description provided (optional)
        timestamp (str): No description provided (optional)
        value (str): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IocObject
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if custom_fields is not None:
        body["CustomFields"] = custom_fields
    if account is not None:
        body["account"] = account
    if aggregated_reliability is not None:
        body["aggregatedReliability"] = aggregated_reliability
    if cache_versn is not None:
        body["cacheVersn"] = cache_versn
    if calculated_time is not None:
        body["calculatedTime"] = calculated_time
    if comment is not None:
        body["comment"] = comment
    if comments is not None:
        body["comments"] = comments
    if created is not None:
        body["created"] = created
    if deleted_feed_fetch_time is not None:
        body["deletedFeedFetchTime"] = deleted_feed_fetch_time
    if expiration is not None:
        body["expiration"] = expiration
    if expiration_source is not None:
        body["expirationSource"] = expiration_source
    if expiration_status is not None:
        body["expirationStatus"] = expiration_status
    if first_seen is not None:
        body["firstSeen"] = first_seen
    if first_seen_entry_id is not None:
        body["firstSeenEntryID"] = first_seen_entry_id
    if highlight is not None:
        body["highlight"] = highlight
    if id is not None:
        body["id"] = id
    if index_name is not None:
        body["indexName"] = index_name
    if indicator_type is not None:
        body["indicator_type"] = indicator_type
    if insight_cache is not None:
        body["insightCache"] = insight_cache
    if investigation_i_ds is not None:
        body["investigationIDs"] = investigation_i_ds
    if is_detectable is not None:
        body["isDetectable"] = is_detectable
    if is_preventable is not None:
        body["isPreventable"] = is_preventable
    if is_shared is not None:
        body["isShared"] = is_shared
    if last_reputation_run is not None:
        body["lastReputationRun"] = last_reputation_run
    if last_seen is not None:
        body["lastSeen"] = last_seen
    if last_seen_entry_id is not None:
        body["lastSeenEntryID"] = last_seen_entry_id
    if manual_expiration_time is not None:
        body["manualExpirationTime"] = manual_expiration_time
    if manual_score is not None:
        body["manualScore"] = manual_score
    if manual_set_time is not None:
        body["manualSetTime"] = manual_set_time
    if manually_edited_fields is not None:
        body["manuallyEditedFields"] = manually_edited_fields
    if modified is not None:
        body["modified"] = modified
    if modified_time is not None:
        body["modifiedTime"] = modified_time
    if module_to_feed_map is not None:
        body["moduleToFeedMap"] = module_to_feed_map
    if numeric_id is not None:
        body["numericId"] = numeric_id
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if related_inc_count is not None:
        body["relatedIncCount"] = related_inc_count
    if score is not None:
        body["score"] = score
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if set_by is not None:
        body["setBy"] = set_by
    if size_in_bytes is not None:
        body["sizeInBytes"] = size_in_bytes
    if sort_values is not None:
        body["sortValues"] = sort_values
    if source is not None:
        body["source"] = source
    if source_brands is not None:
        body["sourceBrands"] = source_brands
    if source_instances is not None:
        body["sourceInstances"] = source_instances
    if sync_hash is not None:
        body["syncHash"] = sync_hash
    if timestamp is not None:
        body["timestamp"] = timestamp
    if value is not None:
        body["value"] = value
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicator/edit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_edit
xsoar_indicators_edit_schema = {
    "type": "object",
    "properties": {
        "custom_fields": {"type": "str", "description": ""},
        "account": {"type": "str", "description": ""},
        "aggregated_reliability": {"type": "str", "description": ""},
        "cache_versn": {"type": "int", "description": ""},
        "calculated_time": {"type": "str", "description": "Do not set the fields bellow this line"},
        "comment": {"type": "str", "description": ""},
        "comments": {"type": "str", "description": ""},
        "created": {"type": "str", "description": ""},
        "deleted_feed_fetch_time": {"type": "str", "description": ""},
        "expiration": {"type": "str", "description": ""},
        "expiration_source": {"type": "str", "description": ""},
        "expiration_status": {"type": "str", "description": ""},
        "first_seen": {"type": "str", "description": ""},
        "first_seen_entry_id": {"type": "str", "description": ""},
        "highlight": {"type": "Dict[str, Any]", "description": ""},
        "id": {"type": "str", "description": ""},
        "index_name": {"type": "str", "description": ""},
        "indicator_type": {"type": "str", "description": ""},
        "insight_cache": {"type": "str", "description": ""},
        "investigation_i_ds": {"type": "List[Any]", "description": ""},
        "is_detectable": {"type": "bool", "description": ""},
        "is_preventable": {"type": "bool", "description": ""},
        "is_shared": {"type": "bool", "description": ""},
        "last_reputation_run": {"type": "str", "description": ""},
        "last_seen": {"type": "str", "description": ""},
        "last_seen_entry_id": {"type": "str", "description": ""},
        "manual_expiration_time": {"type": "str", "description": ""},
        "manual_score": {"type": "bool", "description": ""},
        "manual_set_time": {"type": "str", "description": ""},
        "manually_edited_fields": {"type": "List[Any]", "description": ""},
        "modified": {"type": "str", "description": ""},
        "modified_time": {"type": "str", "description": ""},
        "module_to_feed_map": {"type": "Dict[str, Any]", "description": ""},
        "numeric_id": {"type": "int", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "related_inc_count": {"type": "int", "description": ""},
        "score": {"type": "int", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "set_by": {"type": "str", "description": ""},
        "size_in_bytes": {"type": "int", "description": ""},
        "sort_values": {"type": "List[Any]", "description": ""},
        "source": {"type": "str", "description": ""},
        "source_brands": {"type": "List[Any]", "description": ""},
        "source_instances": {"type": "List[Any]", "description": ""},
        "sync_hash": {"type": "str", "description": ""},
        "timestamp": {"type": "str", "description": ""},
        "value": {"type": "str", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_indicator_whitelist(
    investigation_id: str | None = None,
    do_not_whitelist: bool | None = None,
    entry_id: str | None = None,
    manual_score: bool | None = None,
    reason: str | None = None,
    reputation: int | None = None,
    reputations: List[Any] | None = None,
    value: str | None = None,
) -> List[types.TextContent]:
    """
    Whitelists or deletes an indicator entity
In order to delete an indicator and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        investigation_id (str): No description provided (optional)
        do_not_whitelist (bool): No description provided (optional)
        entry_id (str): No description provided (optional)
        manual_score (bool): No description provided (optional)
        reason (str): No description provided (optional)
        reputation (int): No description provided (optional)
        reputations (List[Any]): No description provided (optional)
        value (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: UpdateResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        body["InvestigationId"] = investigation_id
    if do_not_whitelist is not None:
        body["doNotWhitelist"] = do_not_whitelist
    if entry_id is not None:
        body["entryId"] = entry_id
    if manual_score is not None:
        body["manualScore"] = manual_score
    if reason is not None:
        body["reason"] = reason
    if reputation is not None:
        body["reputation"] = reputation
    if reputations is not None:
        body["reputations"] = reputations
    if value is not None:
        body["value"] = value

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicator/whitelist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicator_whitelist
xsoar_indicator_whitelist_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": ""},
        "do_not_whitelist": {"type": "bool", "description": ""},
        "entry_id": {"type": "str", "description": ""},
        "manual_score": {"type": "bool", "description": ""},
        "reason": {"type": "str", "description": ""},
        "reputation": {"type": "int", "description": ""},
        "reputations": {"type": "List[Any]", "description": ""},
        "value": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_export_indicators_to_stix_batch(
    all: bool | None = None,
    columns: List[Any] | None = None,
    do_not_whitelist: bool | None = None,
    filter: str | None = None,
    ids: List[Any] | None = None,
    reason: str | None = None,
    reputations: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Exports an indicators batch to STIX file (returns file ID)
    
    Args:
        all (bool): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        do_not_whitelist (bool): No description provided (optional)
        filter (str): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        reason (str): No description provided (optional)
        reputations (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: STIX file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if all is not None:
        body["all"] = all
    if columns is not None:
        body["columns"] = columns
    if do_not_whitelist is not None:
        body["doNotWhitelist"] = do_not_whitelist
    if filter is not None:
        body["filter"] = filter
    if ids is not None:
        body["ids"] = ids
    if reason is not None:
        body["reason"] = reason
    if reputations is not None:
        body["reputations"] = reputations

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/batch/export/stix"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_indicators_to_stix_batch
xsoar_export_indicators_to_stix_batch_schema = {
    "type": "object",
    "properties": {
        "all": {"type": "bool", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "do_not_whitelist": {"type": "bool", "description": ""},
        "filter": {"type": "str", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "reason": {"type": "str", "description": ""},
        "reputations": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_export_indicators_to_csv_batch(
    all: bool | None = None,
    columns: List[Any] | None = None,
    do_not_whitelist: bool | None = None,
    filter: str | None = None,
    ids: List[Any] | None = None,
    reason: str | None = None,
    reputations: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Exports an indicators batch to CSV file (returns file ID)
    
    Args:
        all (bool): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        do_not_whitelist (bool): No description provided (optional)
        filter (str): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        reason (str): No description provided (optional)
        reputations (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: csv file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if all is not None:
        body["all"] = all
    if columns is not None:
        body["columns"] = columns
    if do_not_whitelist is not None:
        body["doNotWhitelist"] = do_not_whitelist
    if filter is not None:
        body["filter"] = filter
    if ids is not None:
        body["ids"] = ids
    if reason is not None:
        body["reason"] = reason
    if reputations is not None:
        body["reputations"] = reputations

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_indicators_to_csv_batch
xsoar_export_indicators_to_csv_batch_schema = {
    "type": "object",
    "properties": {
        "all": {"type": "bool", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "do_not_whitelist": {"type": "bool", "description": ""},
        "filter": {"type": "str", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "reason": {"type": "str", "description": ""},
        "reputations": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_delete_indicators_batch(
    all: bool | None = None,
    columns: List[Any] | None = None,
    do_not_whitelist: bool | None = None,
    filter: str | None = None,
    ids: List[Any] | None = None,
    reason: str | None = None,
    reputations: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Batch whitelist or delete indicators entities
In order to delete indicators and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        all (bool): No description provided (optional)
        columns (List[Any]): No description provided (optional)
        do_not_whitelist (bool): No description provided (optional)
        filter (str): No description provided (optional)
        ids (List[Any]): No description provided (optional)
        reason (str): No description provided (optional)
        reputations (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: UpdateResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if all is not None:
        body["all"] = all
    if columns is not None:
        body["columns"] = columns
    if do_not_whitelist is not None:
        body["doNotWhitelist"] = do_not_whitelist
    if filter is not None:
        body["filter"] = filter
    if ids is not None:
        body["ids"] = ids
    if reason is not None:
        body["reason"] = reason
    if reputations is not None:
        body["reputations"] = reputations

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_indicators_batch
xsoar_delete_indicators_batch_schema = {
    "type": "object",
    "properties": {
        "all": {"type": "bool", "description": ""},
        "columns": {"type": "List[Any]", "description": ""},
        "do_not_whitelist": {"type": "bool", "description": ""},
        "filter": {"type": "str", "description": ""},
        "ids": {"type": "List[Any]", "description": ""},
        "reason": {"type": "str", "description": ""},
        "reputations": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_indicators_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators CSV file that was exported, by ID
    
    Args:
        id (str): CSV file to fetch (returned from batch export to csv call) (required)
    
    Returns:
        List[types.TextContent]: Return Csv file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_as_csv
xsoar_indicators_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def xsoar_create_feed_indicators_json(
    bypass_exclusion_list: bool | None = None,
    classifier_id: str | None = None,
    indicators: List[Any] | None = None,
    mapper_id: str | None = None,
) -> List[types.TextContent]:
    """
    Create indicators from raw JSON (similar to ingesting from a feed). Builds indicators according to the specified feed classifier,
or uses the default one if not specified.
Indicator properties (all optional except for value): **value** (string, required) | **type** (string) | **score** (number, 0-3,
default `0`, where `0` means None, `1` Good, `2` Suspicious, and `3` Bad) | **sourceBrand** (string, default `"External"`) | **sourceInstance**
(string, default `"External"`) | **reliability** (string, one of `"A - Completely reliable"`, `"B - Usually reliable"`, `"C - Fairly
reliable"`, `"D - Not usually reliable"`, `"E - Unreliable"`, `"F - Reliability cannot be judged"`) | **expirationPolicy** (string,
one of `"never"`, `"interval"`, `"indicatorType"`) | **expirationInterval** (number, in minutes)
    
    Args:
        bypass_exclusion_list (bool): No description provided (optional)
        classifier_id (str): No description provided (optional)
        indicators (List[Any]): No description provided (optional)
        mapper_id (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: Indicators created
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if bypass_exclusion_list is not None:
        body["bypassExclusionList"] = bypass_exclusion_list
    if classifier_id is not None:
        body["classifierId"] = classifier_id
    if indicators is not None:
        body["indicators"] = indicators
    if mapper_id is not None:
        body["mapperId"] = mapper_id

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/feed/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_feed_indicators_json
xsoar_create_feed_indicators_json_schema = {
    "type": "object",
    "properties": {
        "bypass_exclusion_list": {"type": "bool", "description": ""},
        "classifier_id": {"type": "str", "description": ""},
        "indicators": {"type": "List[Any]", "description": ""},
        "mapper_id": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_indicators_search(
    cache: Dict[str, Any] | None = None,
    accounts: Dict[str, Any] | None = None,
    early_time_in_page: str | None = None,
    fields: List[Any] | None = None,
    filterobjectquery: str | None = None,
    first_seen: str | None = None,
    from_date: str | None = None,
    from_date_license: str | None = None,
    ignore_workers: bool | None = None,
    last_seen: str | None = None,
    later_time_in_page: str | None = None,
    page: int | None = None,
    period: str | None = None,
    prev_page: bool | None = None,
    query: str | None = None,
    search_after: List[Any] | None = None,
    search_after_elastic: List[Any] | None = None,
    search_after_map: Dict[str, Any] | None = None,
    search_after_map_order: Dict[str, Any] | None = None,
    search_before: List[Any] | None = None,
    search_before_elastic: List[Any] | None = None,
    size: int | None = None,
    sort: List[Any] | None = None,
    time_frame: str | None = None,
    to_date: str | None = None,
    trim_events: int | None = None,
) -> List[types.TextContent]:
    """
    Search indicators by filter
    
    Args:
        cache (Dict[str, Any]): Cache of join functions (optional)
        accounts (Dict[str, Any]): No description provided (optional)
        early_time_in_page (str): No description provided (optional)
        fields (List[Any]): No description provided (optional)
        filterobjectquery (str): No description provided (optional)
        first_seen (str): No description provided (optional)
        from_date (str): No description provided (optional)
        from_date_license (str): No description provided (optional)
        ignore_workers (bool): Do not use workers mechanism while searching bleve (optional)
        last_seen (str): No description provided (optional)
        later_time_in_page (str): No description provided (optional)
        page (int): 0-based page (optional)
        period (str): No description provided (optional)
        prev_page (bool): MT support - these fields are for indicator search according to calculatedTime (optional)
        query (str): No description provided (optional)
        search_after (List[Any]): Efficient next page, pass max sort value from previous page (optional)
        search_after_elastic (List[Any]): Efficient next page, pass max ES sort value from previous page (optional)
        search_after_map (Dict[str, Any]): Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map. (optional)
        search_after_map_order (Dict[str, Any]): No description provided (optional)
        search_before (List[Any]): Efficient prev page, pass min sort value from next page (optional)
        search_before_elastic (List[Any]): Efficient prev page, pass min ES sort value from next page (optional)
        size (int): Size is limited to 1000, if not passed it defaults to 0, and no results will return (optional)
        sort (List[Any]): The sort order (optional)
        time_frame (str): No description provided (optional)
        to_date (str): No description provided (optional)
        trim_events (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: indicatorResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if cache is not None:
        body["Cache"] = cache
    if accounts is not None:
        body["accounts"] = accounts
    if early_time_in_page is not None:
        body["earlyTimeInPage"] = early_time_in_page
    if fields is not None:
        body["fields"] = fields
    if filterobjectquery is not None:
        body["filterobjectquery"] = filterobjectquery
    if first_seen is not None:
        body["firstSeen"] = first_seen
    if from_date is not None:
        body["fromDate"] = from_date
    if from_date_license is not None:
        body["fromDateLicense"] = from_date_license
    if ignore_workers is not None:
        body["ignoreWorkers"] = ignore_workers
    if last_seen is not None:
        body["lastSeen"] = last_seen
    if later_time_in_page is not None:
        body["laterTimeInPage"] = later_time_in_page
    if page is not None:
        body["page"] = page
    if period is not None:
        body["period"] = period
    if prev_page is not None:
        body["prevPage"] = prev_page
    if query is not None:
        body["query"] = query
    if search_after is not None:
        body["searchAfter"] = search_after
    if search_after_elastic is not None:
        body["searchAfterElastic"] = search_after_elastic
    if search_after_map is not None:
        body["searchAfterMap"] = search_after_map
    if search_after_map_order is not None:
        body["searchAfterMapOrder"] = search_after_map_order
    if search_before is not None:
        body["searchBefore"] = search_before
    if search_before_elastic is not None:
        body["searchBeforeElastic"] = search_before_elastic
    if size is not None:
        body["size"] = size
    if sort is not None:
        body["sort"] = sort
    if time_frame is not None:
        body["timeFrame"] = time_frame
    if to_date is not None:
        body["toDate"] = to_date
    if trim_events is not None:
        body["trim_events"] = trim_events

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_search
xsoar_indicators_search_schema = {
    "type": "object",
    "properties": {
        "cache": {"type": "Dict[str, Any]", "description": "Cache of join functions"},
        "accounts": {"type": "Dict[str, Any]", "description": ""},
        "early_time_in_page": {"type": "str", "description": ""},
        "fields": {"type": "List[Any]", "description": ""},
        "filterobjectquery": {"type": "str", "description": ""},
        "first_seen": {"type": "str", "description": ""},
        "from_date": {"type": "str", "description": ""},
        "from_date_license": {"type": "str", "description": ""},
        "ignore_workers": {"type": "bool", "description": "Do not use workers mechanism while searching bleve"},
        "last_seen": {"type": "str", "description": ""},
        "later_time_in_page": {"type": "str", "description": ""},
        "page": {"type": "int", "description": "0-based page"},
        "period": {"type": "str", "description": ""},
        "prev_page": {"type": "bool", "description": "MT support - these fields are for indicator search according to calculatedTime"},
        "query": {"type": "str", "description": ""},
        "search_after": {"type": "List[Any]", "description": "Efficient next page, pass max sort value from previous page"},
        "search_after_elastic": {"type": "List[Any]", "description": "Efficient next page, pass max ES sort value from previous page"},
        "search_after_map": {"type": "Dict[str, Any]", "description": "Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map."},
        "search_after_map_order": {"type": "Dict[str, Any]", "description": ""},
        "search_before": {"type": "List[Any]", "description": "Efficient prev page, pass min sort value from next page"},
        "search_before_elastic": {"type": "List[Any]", "description": "Efficient prev page, pass min ES sort value from next page"},
        "size": {"type": "int", "description": "Size is limited to 1000, if not passed it defaults to 0, and no results will return"},
        "sort": {"type": "List[Any]", "description": "The sort order"},
        "time_frame": {"type": "str", "description": ""},
        "to_date": {"type": "str", "description": ""},
        "trim_events": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_indicators_as_stix(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators STIX V2 file that was exported, by ID
    
    Args:
        id (str): STIX V2 file to fetch (returned from batch export to STIX call) (required)
    
    Returns:
        List[types.TextContent]: Return STIX V2 file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/stix/v2/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_as_stix
xsoar_indicators_as_stix_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "STIX V2 file to fetch (returned from batch export to STIX call)"},
    },
}

@server.call_tool()
async def xsoar_indicators_timeline_delete(
    cache: Dict[str, Any] | None = None,
    accounts: Dict[str, Any] | None = None,
    early_time_in_page: str | None = None,
    fields: List[Any] | None = None,
    filterobjectquery: str | None = None,
    first_seen: str | None = None,
    from_date: str | None = None,
    from_date_license: str | None = None,
    ignore_workers: bool | None = None,
    last_seen: str | None = None,
    later_time_in_page: str | None = None,
    page: int | None = None,
    period: str | None = None,
    prev_page: bool | None = None,
    query: str | None = None,
    search_after: List[Any] | None = None,
    search_after_elastic: List[Any] | None = None,
    search_after_map: Dict[str, Any] | None = None,
    search_after_map_order: Dict[str, Any] | None = None,
    search_before: List[Any] | None = None,
    search_before_elastic: List[Any] | None = None,
    size: int | None = None,
    sort: List[Any] | None = None,
    time_frame: str | None = None,
    to_date: str | None = None,
    trim_events: int | None = None,
) -> List[types.TextContent]:
    """
    Delete indicators timeline by filter
    
    Args:
        cache (Dict[str, Any]): Cache of join functions (optional)
        accounts (Dict[str, Any]): No description provided (optional)
        early_time_in_page (str): No description provided (optional)
        fields (List[Any]): No description provided (optional)
        filterobjectquery (str): No description provided (optional)
        first_seen (str): No description provided (optional)
        from_date (str): No description provided (optional)
        from_date_license (str): No description provided (optional)
        ignore_workers (bool): Do not use workers mechanism while searching bleve (optional)
        last_seen (str): No description provided (optional)
        later_time_in_page (str): No description provided (optional)
        page (int): 0-based page (optional)
        period (str): No description provided (optional)
        prev_page (bool): MT support - these fields are for indicator search according to calculatedTime (optional)
        query (str): No description provided (optional)
        search_after (List[Any]): Efficient next page, pass max sort value from previous page (optional)
        search_after_elastic (List[Any]): Efficient next page, pass max ES sort value from previous page (optional)
        search_after_map (Dict[str, Any]): Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map. (optional)
        search_after_map_order (Dict[str, Any]): No description provided (optional)
        search_before (List[Any]): Efficient prev page, pass min sort value from next page (optional)
        search_before_elastic (List[Any]): Efficient prev page, pass min ES sort value from next page (optional)
        size (int): Size is limited to 1000, if not passed it defaults to 0, and no results will return (optional)
        sort (List[Any]): The sort order (optional)
        time_frame (str): No description provided (optional)
        to_date (str): No description provided (optional)
        trim_events (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: IndicatorEditBulkResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if cache is not None:
        body["Cache"] = cache
    if accounts is not None:
        body["accounts"] = accounts
    if early_time_in_page is not None:
        body["earlyTimeInPage"] = early_time_in_page
    if fields is not None:
        body["fields"] = fields
    if filterobjectquery is not None:
        body["filterobjectquery"] = filterobjectquery
    if first_seen is not None:
        body["firstSeen"] = first_seen
    if from_date is not None:
        body["fromDate"] = from_date
    if from_date_license is not None:
        body["fromDateLicense"] = from_date_license
    if ignore_workers is not None:
        body["ignoreWorkers"] = ignore_workers
    if last_seen is not None:
        body["lastSeen"] = last_seen
    if later_time_in_page is not None:
        body["laterTimeInPage"] = later_time_in_page
    if page is not None:
        body["page"] = page
    if period is not None:
        body["period"] = period
    if prev_page is not None:
        body["prevPage"] = prev_page
    if query is not None:
        body["query"] = query
    if search_after is not None:
        body["searchAfter"] = search_after
    if search_after_elastic is not None:
        body["searchAfterElastic"] = search_after_elastic
    if search_after_map is not None:
        body["searchAfterMap"] = search_after_map
    if search_after_map_order is not None:
        body["searchAfterMapOrder"] = search_after_map_order
    if search_before is not None:
        body["searchBefore"] = search_before
    if search_before_elastic is not None:
        body["searchBeforeElastic"] = search_before_elastic
    if size is not None:
        body["size"] = size
    if sort is not None:
        body["sort"] = sort
    if time_frame is not None:
        body["timeFrame"] = time_frame
    if to_date is not None:
        body["toDate"] = to_date
    if trim_events is not None:
        body["trim_events"] = trim_events

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/timeline/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_timeline_delete
xsoar_indicators_timeline_delete_schema = {
    "type": "object",
    "properties": {
        "cache": {"type": "Dict[str, Any]", "description": "Cache of join functions"},
        "accounts": {"type": "Dict[str, Any]", "description": ""},
        "early_time_in_page": {"type": "str", "description": ""},
        "fields": {"type": "List[Any]", "description": ""},
        "filterobjectquery": {"type": "str", "description": ""},
        "first_seen": {"type": "str", "description": ""},
        "from_date": {"type": "str", "description": ""},
        "from_date_license": {"type": "str", "description": ""},
        "ignore_workers": {"type": "bool", "description": "Do not use workers mechanism while searching bleve"},
        "last_seen": {"type": "str", "description": ""},
        "later_time_in_page": {"type": "str", "description": ""},
        "page": {"type": "int", "description": "0-based page"},
        "period": {"type": "str", "description": ""},
        "prev_page": {"type": "bool", "description": "MT support - these fields are for indicator search according to calculatedTime"},
        "query": {"type": "str", "description": ""},
        "search_after": {"type": "List[Any]", "description": "Efficient next page, pass max sort value from previous page"},
        "search_after_elastic": {"type": "List[Any]", "description": "Efficient next page, pass max ES sort value from previous page"},
        "search_after_map": {"type": "Dict[str, Any]", "description": "Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map."},
        "search_after_map_order": {"type": "Dict[str, Any]", "description": ""},
        "search_before": {"type": "List[Any]", "description": "Efficient prev page, pass min sort value from next page"},
        "search_before_elastic": {"type": "List[Any]", "description": "Efficient prev page, pass min ES sort value from next page"},
        "size": {"type": "int", "description": "Size is limited to 1000, if not passed it defaults to 0, and no results will return"},
        "sort": {"type": "List[Any]", "description": "The sort order"},
        "time_frame": {"type": "str", "description": ""},
        "to_date": {"type": "str", "description": ""},
        "trim_events": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_indicators_create_batch(

) -> List[types.TextContent]:
    """
    Create indicators from a file
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IocObjects
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_create_batch
xsoar_indicators_create_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_or_update_whitelisted(
    cache_versn: int | None = None,
    created: str | None = None,
    highlight: Dict[str, Any] | None = None,
    id: str | None = None,
    index_name: str | None = None,
    locked: bool | None = None,
    modified: str | None = None,
    numeric_id: int | None = None,
    primary_term: int | None = None,
    reason: str | None = None,
    reputations: List[Any] | None = None,
    sequence_number: int | None = None,
    size_in_bytes: int | None = None,
    sort_values: List[Any] | None = None,
    sync_hash: str | None = None,
    type: str | None = None,
    user: str | None = None,
    value: str | None = None,
    version: int | None = None,
    whitelist_time: str | None = None,
) -> List[types.TextContent]:
    """
    Create or update excluded indicators list
    
    Args:
        cache_versn (int): No description provided (optional)
        created (str): No description provided (optional)
        highlight (Dict[str, Any]): No description provided (optional)
        id (str): No description provided (optional)
        index_name (str): No description provided (optional)
        locked (bool): No description provided (optional)
        modified (str): No description provided (optional)
        numeric_id (int): No description provided (optional)
        primary_term (int): No description provided (optional)
        reason (str): No description provided (optional)
        reputations (List[Any]): No description provided (optional)
        sequence_number (int): No description provided (optional)
        size_in_bytes (int): No description provided (optional)
        sort_values (List[Any]): No description provided (optional)
        sync_hash (str): No description provided (optional)
        type (str): No description provided (optional)
        user (str): No description provided (optional)
        value (str): No description provided (optional)
        version (int): No description provided (optional)
        whitelist_time (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: WhitelistedIndicator
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if cache_versn is not None:
        body["cacheVersn"] = cache_versn
    if created is not None:
        body["created"] = created
    if highlight is not None:
        body["highlight"] = highlight
    if id is not None:
        body["id"] = id
    if index_name is not None:
        body["indexName"] = index_name
    if locked is not None:
        body["locked"] = locked
    if modified is not None:
        body["modified"] = modified
    if numeric_id is not None:
        body["numericId"] = numeric_id
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if reason is not None:
        body["reason"] = reason
    if reputations is not None:
        body["reputations"] = reputations
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if size_in_bytes is not None:
        body["sizeInBytes"] = size_in_bytes
    if sort_values is not None:
        body["sortValues"] = sort_values
    if sync_hash is not None:
        body["syncHash"] = sync_hash
    if type is not None:
        body["type"] = type
    if user is not None:
        body["user"] = user
    if value is not None:
        body["value"] = value
    if version is not None:
        body["version"] = version
    if whitelist_time is not None:
        body["whitelistTime"] = whitelist_time

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/whitelist/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_or_update_whitelisted
xsoar_create_or_update_whitelisted_schema = {
    "type": "object",
    "properties": {
        "cache_versn": {"type": "int", "description": ""},
        "created": {"type": "str", "description": ""},
        "highlight": {"type": "Dict[str, Any]", "description": ""},
        "id": {"type": "str", "description": ""},
        "index_name": {"type": "str", "description": ""},
        "locked": {"type": "bool", "description": ""},
        "modified": {"type": "str", "description": ""},
        "numeric_id": {"type": "int", "description": ""},
        "primary_term": {"type": "int", "description": ""},
        "reason": {"type": "str", "description": ""},
        "reputations": {"type": "List[Any]", "description": ""},
        "sequence_number": {"type": "int", "description": ""},
        "size_in_bytes": {"type": "int", "description": ""},
        "sort_values": {"type": "List[Any]", "description": ""},
        "sync_hash": {"type": "str", "description": ""},
        "type": {"type": "str", "description": ""},
        "user": {"type": "str", "description": ""},
        "value": {"type": "str", "description": ""},
        "version": {"type": "int", "description": ""},
        "whitelist_time": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_add_ad_hoc_task(
    investigation_id: str,
    add_after: bool | None = None,
    add_to_separate_branch: bool | None = None,
    automation_script: str | None = None,
    description: str | None = None,
    loop: str | None = None,
    name: str | None = None,
    neighbor_inv_pb_task_id: str | None = None,
    playbook_id: str | None = None,
    script_arguments: Dict[str, Any] | None = None,
    separate_context: bool | None = None,
    tags: List[Any] | None = None,
    type: str | None = None,
) -> List[types.TextContent]:
    """
    Add an ad-hoc task to a running playbook
    
    Args:
        investigation_id (str): investigation ID (required)
        add_after (bool): No description provided (optional)
        add_to_separate_branch (bool): No description provided (optional)
        automation_script (str): No description provided (optional)
        description (str): No description provided (optional)
        loop (str): No description provided (optional)
        name (str): No description provided (optional)
        neighbor_inv_pb_task_id (str): No description provided (optional)
        playbook_id (str): No description provided (optional)
        script_arguments (Dict[str, Any]): No description provided (optional)
        separate_context (bool): No description provided (optional)
        tags (List[Any]): No description provided (optional)
        type (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if add_after is not None:
        body["addAfter"] = add_after
    if add_to_separate_branch is not None:
        body["addToSeparateBranch"] = add_to_separate_branch
    if automation_script is not None:
        body["automationScript"] = automation_script
    if description is not None:
        body["description"] = description
    if loop is not None:
        body["loop"] = loop
    if name is not None:
        body["name"] = name
    if neighbor_inv_pb_task_id is not None:
        body["neighborInvPBTaskId"] = neighbor_inv_pb_task_id
    if playbook_id is not None:
        body["playbookId"] = playbook_id
    if script_arguments is not None:
        body["scriptArguments"] = script_arguments
    if separate_context is not None:
        body["separateContext"] = separate_context
    if tags is not None:
        body["tags"] = tags
    if type is not None:
        body["type"] = type
    if investigation_id is not None:
        path_params["investigationId"] = sanitize_input(investigation_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/add/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_add_ad_hoc_task
xsoar_add_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
        "add_after": {"type": "bool", "description": ""},
        "add_to_separate_branch": {"type": "bool", "description": ""},
        "automation_script": {"type": "str", "description": ""},
        "description": {"type": "str", "description": ""},
        "loop": {"type": "str", "description": ""},
        "name": {"type": "str", "description": ""},
        "neighbor_inv_pb_task_id": {"type": "str", "description": ""},
        "playbook_id": {"type": "str", "description": ""},
        "script_arguments": {"type": "Dict[str, Any]", "description": ""},
        "separate_context": {"type": "bool", "description": ""},
        "tags": {"type": "List[Any]", "description": ""},
        "type": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_task_assign(
    assignee: str | None = None,
    in_task_id: str | None = None,
    inv_id: str | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Assign a task to an owner
    
    Args:
        assignee (str): No description provided (optional)
        in_task_id (str): No description provided (optional)
        inv_id (str): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if assignee is not None:
        body["assignee"] = assignee
    if in_task_id is not None:
        body["inTaskID"] = in_task_id
    if inv_id is not None:
        body["invId"] = inv_id
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/assign"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_assign
xsoar_task_assign_schema = {
    "type": "object",
    "properties": {
        "assignee": {"type": "str", "description": ""},
        "in_task_id": {"type": "str", "description": ""},
        "inv_id": {"type": "str", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_complete_task(

) -> List[types.TextContent]:
    """
    Complete a task with a file attachment
Deprecated - use "/v2/inv-playbook/task/complete"
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_complete_task
xsoar_complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_simple_complete_task(
    args: Dict[str, Any] | None = None,
    comment: str | None = None,
    conditions: List[Any] | None = None,
    in_task_id: str | None = None,
    input: str | None = None,
    inv_id: str | None = None,
    loop_args: Dict[str, Any] | None = None,
    loop_condition: List[Any] | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Complete a task without a file attachment
    
    Args:
        args (Dict[str, Any]): No description provided (optional)
        comment (str): No description provided (optional)
        conditions (List[Any]): No description provided (optional)
        in_task_id (str): No description provided (optional)
        input (str): No description provided (optional)
        inv_id (str): No description provided (optional)
        loop_args (Dict[str, Any]): No description provided (optional)
        loop_condition (List[Any]): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if args is not None:
        body["args"] = args
    if comment is not None:
        body["comment"] = comment
    if conditions is not None:
        body["conditions"] = conditions
    if in_task_id is not None:
        body["inTaskID"] = in_task_id
    if input is not None:
        body["input"] = input
    if inv_id is not None:
        body["invId"] = inv_id
    if loop_args is not None:
        body["loopArgs"] = loop_args
    if loop_condition is not None:
        body["loopCondition"] = loop_condition
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/complete/simple"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_simple_complete_task
xsoar_simple_complete_task_schema = {
    "type": "object",
    "properties": {
        "args": {"type": "Dict[str, Any]", "description": ""},
        "comment": {"type": "str", "description": ""},
        "conditions": {"type": "List[Any]", "description": ""},
        "in_task_id": {"type": "str", "description": ""},
        "input": {"type": "str", "description": ""},
        "inv_id": {"type": "str", "description": ""},
        "loop_args": {"type": "Dict[str, Any]", "description": ""},
        "loop_condition": {"type": "List[Any]", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_delete_ad_hoc_task(
    inv_pb_task_id: str,
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Delete an ad-hoc task from a running playbook
    
    Args:
        inv_pb_task_id (str): ad-hoc task ID (required)
        investigation_id (str): investigation ID (required)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if inv_pb_task_id is not None:
        path_params["invPBTaskId"] = sanitize_input(inv_pb_task_id)
    if investigation_id is not None:
        path_params["investigationId"] = sanitize_input(investigation_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/delete/{investigationId}/{invPBTaskId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_ad_hoc_task
xsoar_delete_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "inv_pb_task_id": {"type": "str", "description": "ad-hoc task ID"},
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_set_due(
    date: str | None = None,
    in_task_id: str | None = None,
    inv_id: str | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Set the task due date
    
    Args:
        date (str): No description provided (optional)
        in_task_id (str): No description provided (optional)
        inv_id (str): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if date is not None:
        body["date"] = date
    if in_task_id is not None:
        body["inTaskID"] = in_task_id
    if inv_id is not None:
        body["invId"] = inv_id
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/due"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_set_due
xsoar_task_set_due_schema = {
    "type": "object",
    "properties": {
        "date": {"type": "str", "description": ""},
        "in_task_id": {"type": "str", "description": ""},
        "inv_id": {"type": "str", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_edit_ad_hoc_task(
    investigation_id: str,
    add_after: bool | None = None,
    add_to_separate_branch: bool | None = None,
    automation_script: str | None = None,
    description: str | None = None,
    loop: str | None = None,
    name: str | None = None,
    neighbor_inv_pb_task_id: str | None = None,
    playbook_id: str | None = None,
    script_arguments: Dict[str, Any] | None = None,
    separate_context: bool | None = None,
    tags: List[Any] | None = None,
    type: str | None = None,
) -> List[types.TextContent]:
    """
    Edit an ad-hoc task in a running playbook
    
    Args:
        investigation_id (str): investigation ID (required)
        add_after (bool): No description provided (optional)
        add_to_separate_branch (bool): No description provided (optional)
        automation_script (str): No description provided (optional)
        description (str): No description provided (optional)
        loop (str): No description provided (optional)
        name (str): No description provided (optional)
        neighbor_inv_pb_task_id (str): No description provided (optional)
        playbook_id (str): No description provided (optional)
        script_arguments (Dict[str, Any]): No description provided (optional)
        separate_context (bool): No description provided (optional)
        tags (List[Any]): No description provided (optional)
        type (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if add_after is not None:
        body["addAfter"] = add_after
    if add_to_separate_branch is not None:
        body["addToSeparateBranch"] = add_to_separate_branch
    if automation_script is not None:
        body["automationScript"] = automation_script
    if description is not None:
        body["description"] = description
    if loop is not None:
        body["loop"] = loop
    if name is not None:
        body["name"] = name
    if neighbor_inv_pb_task_id is not None:
        body["neighborInvPBTaskId"] = neighbor_inv_pb_task_id
    if playbook_id is not None:
        body["playbookId"] = playbook_id
    if script_arguments is not None:
        body["scriptArguments"] = script_arguments
    if separate_context is not None:
        body["separateContext"] = separate_context
    if tags is not None:
        body["tags"] = tags
    if type is not None:
        body["type"] = type
    if investigation_id is not None:
        path_params["investigationId"] = sanitize_input(investigation_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/edit/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_edit_ad_hoc_task
xsoar_edit_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
        "add_after": {"type": "bool", "description": ""},
        "add_to_separate_branch": {"type": "bool", "description": ""},
        "automation_script": {"type": "str", "description": ""},
        "description": {"type": "str", "description": ""},
        "loop": {"type": "str", "description": ""},
        "name": {"type": "str", "description": ""},
        "neighbor_inv_pb_task_id": {"type": "str", "description": ""},
        "playbook_id": {"type": "str", "description": ""},
        "script_arguments": {"type": "Dict[str, Any]", "description": ""},
        "separate_context": {"type": "bool", "description": ""},
        "tags": {"type": "List[Any]", "description": ""},
        "type": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_task_add_comment(
    args: Dict[str, Any] | None = None,
    comment: str | None = None,
    conditions: List[Any] | None = None,
    in_task_id: str | None = None,
    input: str | None = None,
    inv_id: str | None = None,
    loop_args: Dict[str, Any] | None = None,
    loop_condition: List[Any] | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Add comment to a task
    
    Args:
        args (Dict[str, Any]): No description provided (optional)
        comment (str): No description provided (optional)
        conditions (List[Any]): No description provided (optional)
        in_task_id (str): No description provided (optional)
        input (str): No description provided (optional)
        inv_id (str): No description provided (optional)
        loop_args (Dict[str, Any]): No description provided (optional)
        loop_condition (List[Any]): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if args is not None:
        body["args"] = args
    if comment is not None:
        body["comment"] = comment
    if conditions is not None:
        body["conditions"] = conditions
    if in_task_id is not None:
        body["inTaskID"] = in_task_id
    if input is not None:
        body["input"] = input
    if inv_id is not None:
        body["invId"] = inv_id
    if loop_args is not None:
        body["loopArgs"] = loop_args
    if loop_condition is not None:
        body["loopCondition"] = loop_condition
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/note/add"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_add_comment
xsoar_task_add_comment_schema = {
    "type": "object",
    "properties": {
        "args": {"type": "Dict[str, Any]", "description": ""},
        "comment": {"type": "str", "description": ""},
        "conditions": {"type": "List[Any]", "description": ""},
        "in_task_id": {"type": "str", "description": ""},
        "input": {"type": "str", "description": ""},
        "inv_id": {"type": "str", "description": ""},
        "loop_args": {"type": "Dict[str, Any]", "description": ""},
        "loop_condition": {"type": "List[Any]", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_task_un_complete(
    args: Dict[str, Any] | None = None,
    comment: str | None = None,
    conditions: List[Any] | None = None,
    in_task_id: str | None = None,
    input: str | None = None,
    inv_id: str | None = None,
    loop_args: Dict[str, Any] | None = None,
    loop_condition: List[Any] | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Reopen a closed task and change the status to uncomplete
    
    Args:
        args (Dict[str, Any]): No description provided (optional)
        comment (str): No description provided (optional)
        conditions (List[Any]): No description provided (optional)
        in_task_id (str): No description provided (optional)
        input (str): No description provided (optional)
        inv_id (str): No description provided (optional)
        loop_args (Dict[str, Any]): No description provided (optional)
        loop_condition (List[Any]): No description provided (optional)
        version (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if args is not None:
        body["args"] = args
    if comment is not None:
        body["comment"] = comment
    if conditions is not None:
        body["conditions"] = conditions
    if in_task_id is not None:
        body["inTaskID"] = in_task_id
    if input is not None:
        body["input"] = input
    if inv_id is not None:
        body["invId"] = inv_id
    if loop_args is not None:
        body["loopArgs"] = loop_args
    if loop_condition is not None:
        body["loopCondition"] = loop_condition
    if version is not None:
        body["version"] = version

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/uncomplete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_un_complete
xsoar_task_un_complete_schema = {
    "type": "object",
    "properties": {
        "args": {"type": "Dict[str, Any]", "description": ""},
        "comment": {"type": "str", "description": ""},
        "conditions": {"type": "List[Any]", "description": ""},
        "in_task_id": {"type": "str", "description": ""},
        "input": {"type": "str", "description": ""},
        "inv_id": {"type": "str", "description": ""},
        "loop_args": {"type": "Dict[str, Any]", "description": ""},
        "loop_condition": {"type": "List[Any]", "description": ""},
        "version": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_search_investigations(
    filter: str | None = None,
) -> List[types.TextContent]:
    """
    This will search investigations across all indices
You can filter by multiple options
    
    Args:
        filter (str): No description provided (optional)
    
    Returns:
        List[types.TextContent]: investigationSearchResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if filter is not None:
        body["filter"] = filter

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/investigations/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_investigations
xsoar_search_investigations_schema = {
    "type": "object",
    "properties": {
        "filter": {"type": "str", "description": ""},
    },
}

@server.call_tool()
async def xsoar_logout_everyone_handler(

) -> List[types.TextContent]:
    """
    Sign out all open users sessions
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/everyone"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_everyone_handler
xsoar_logout_everyone_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_myself_handler(

) -> List[types.TextContent]:
    """
    Sign out all my open sessions
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/myself"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_myself_handler
xsoar_logout_myself_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_myself_other_sessions_handler(

) -> List[types.TextContent]:
    """
    Sign out all my other open sessions
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/myself/other"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_myself_other_sessions_handler
xsoar_logout_myself_other_sessions_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_user_sessions_handler(
    username: str,
) -> List[types.TextContent]:
    """
    Sign out all sessions of the provided username
    
    Args:
        username (str): Username to logout (required)
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = sanitize_input(username)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_user_sessions_handler
xsoar_logout_user_sessions_handler_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "Username to logout"},
    },
}

@server.call_tool()
async def xsoar_override_playbook_yaml(

) -> List[types.TextContent]:
    """
    Import and override playbook in Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved playbook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/playbook/save/yaml"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_override_playbook_yaml
xsoar_override_playbook_yaml_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_download_latest_report(
    id: str,
) -> List[types.TextContent]:
    """
    Get the latest report by its ID.

**Note:** To get the report, it must be a scheduled report with recipients.
    
    Args:
        id (str): the ID of the report to get (required)
    
    Returns:
        List[types.TextContent]: Return a report file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/report/{id}/latest"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_download_latest_report
xsoar_download_latest_report_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_execute_report(
    request_id: str,
    id: str,
) -> List[types.TextContent]:
    """
    Execute a new report
    
    Args:
        request_id (str): the ID to register the request under (required)
        id (str): the ID of the report to get (required)
    
    Returns:
        List[types.TextContent]: Request registered
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_id is not None:
        path_params["requestId"] = sanitize_input(request_id)
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/report/{id}/{requestId}/execute"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_execute_report
xsoar_execute_report_schema = {
    "type": "object",
    "properties": {
        "request_id": {"type": "str", "description": "the ID to register the request under"},
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_all_reports(

) -> List[types.TextContent]:
    """
    Get all of the reports
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return array of reports
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/reports"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_all_reports
xsoar_all_reports_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_upload_report(

) -> List[types.TextContent]:
    """
    Upload a report to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: A list of all the reports in the instance
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/reports/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_upload_report
xsoar_upload_report_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_report_by_id(
    id: str,
) -> List[types.TextContent]:
    """
    Get a report by its ID
    
    Args:
        id (str): the ID of the report to get (required)
    
    Returns:
        List[types.TextContent]: Return a report
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/reports/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_report_by_id
xsoar_report_by_id_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_get_audits(
    cache: Dict[str, Any] | None = None,
    accounts: Dict[str, Any] | None = None,
    fields: List[Any] | None = None,
    filterobjectquery: str | None = None,
    from_date: str | None = None,
    from_date_license: str | None = None,
    ignore_workers: bool | None = None,
    page: int | None = None,
    period: str | None = None,
    query: str | None = None,
    search_after: List[Any] | None = None,
    search_after_elastic: List[Any] | None = None,
    search_after_map: Dict[str, Any] | None = None,
    search_after_map_order: Dict[str, Any] | None = None,
    search_before: List[Any] | None = None,
    search_before_elastic: List[Any] | None = None,
    size: int | None = None,
    sort: List[Any] | None = None,
    time_frame: str | None = None,
    to_date: str | None = None,
    trim_events: int | None = None,
) -> List[types.TextContent]:
    """
    Get audits by filter
    
    Args:
        cache (Dict[str, Any]): Cache of join functions (optional)
        accounts (Dict[str, Any]): No description provided (optional)
        fields (List[Any]): No description provided (optional)
        filterobjectquery (str): No description provided (optional)
        from_date (str): No description provided (optional)
        from_date_license (str): No description provided (optional)
        ignore_workers (bool): Do not use workers mechanism while searching bleve (optional)
        page (int): 0-based page (optional)
        period (str): No description provided (optional)
        query (str): No description provided (optional)
        search_after (List[Any]): Efficient next page, pass max sort value from previous page (optional)
        search_after_elastic (List[Any]): Efficient next page, pass max ES sort value from previous page (optional)
        search_after_map (Dict[str, Any]): Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map. (optional)
        search_after_map_order (Dict[str, Any]): No description provided (optional)
        search_before (List[Any]): Efficient prev page, pass min sort value from next page (optional)
        search_before_elastic (List[Any]): Efficient prev page, pass min ES sort value from next page (optional)
        size (int): Size is limited to 1000, if not passed it defaults to 0, and no results will return (optional)
        sort (List[Any]): The sort order (optional)
        time_frame (str): No description provided (optional)
        to_date (str): No description provided (optional)
        trim_events (int): No description provided (optional)
    
    Returns:
        List[types.TextContent]: auditResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if cache is not None:
        body["Cache"] = cache
    if accounts is not None:
        body["accounts"] = accounts
    if fields is not None:
        body["fields"] = fields
    if filterobjectquery is not None:
        body["filterobjectquery"] = filterobjectquery
    if from_date is not None:
        body["fromDate"] = from_date
    if from_date_license is not None:
        body["fromDateLicense"] = from_date_license
    if ignore_workers is not None:
        body["ignoreWorkers"] = ignore_workers
    if page is not None:
        body["page"] = page
    if period is not None:
        body["period"] = period
    if query is not None:
        body["query"] = query
    if search_after is not None:
        body["searchAfter"] = search_after
    if search_after_elastic is not None:
        body["searchAfterElastic"] = search_after_elastic
    if search_after_map is not None:
        body["searchAfterMap"] = search_after_map
    if search_after_map_order is not None:
        body["searchAfterMapOrder"] = search_after_map_order
    if search_before is not None:
        body["searchBefore"] = search_before
    if search_before_elastic is not None:
        body["searchBeforeElastic"] = search_before_elastic
    if size is not None:
        body["size"] = size
    if sort is not None:
        body["sort"] = sort
    if time_frame is not None:
        body["timeFrame"] = time_frame
    if to_date is not None:
        body["toDate"] = to_date
    if trim_events is not None:
        body["trim_events"] = trim_events

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/audits"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_audits
xsoar_get_audits_schema = {
    "type": "object",
    "properties": {
        "cache": {"type": "Dict[str, Any]", "description": "Cache of join functions"},
        "accounts": {"type": "Dict[str, Any]", "description": ""},
        "fields": {"type": "List[Any]", "description": ""},
        "filterobjectquery": {"type": "str", "description": ""},
        "from_date": {"type": "str", "description": ""},
        "from_date_license": {"type": "str", "description": ""},
        "ignore_workers": {"type": "bool", "description": "Do not use workers mechanism while searching bleve"},
        "page": {"type": "int", "description": "0-based page"},
        "period": {"type": "str", "description": ""},
        "query": {"type": "str", "description": ""},
        "search_after": {"type": "List[Any]", "description": "Efficient next page, pass max sort value from previous page"},
        "search_after_elastic": {"type": "List[Any]", "description": "Efficient next page, pass max ES sort value from previous page"},
        "search_after_map": {"type": "Dict[str, Any]", "description": "Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map."},
        "search_after_map_order": {"type": "Dict[str, Any]", "description": ""},
        "search_before": {"type": "List[Any]", "description": "Efficient prev page, pass min sort value from next page"},
        "search_before_elastic": {"type": "List[Any]", "description": "Efficient prev page, pass min ES sort value from next page"},
        "size": {"type": "int", "description": "Size is limited to 1000, if not passed it defaults to 0, and no results will return"},
        "sort": {"type": "List[Any]", "description": "The sort order"},
        "time_frame": {"type": "str", "description": ""},
        "to_date": {"type": "str", "description": ""},
        "trim_events": {"type": "int", "description": ""},
    },
}

@server.call_tool()
async def xsoar_docker_images(

) -> List[types.TextContent]:
    """
    Get list of all available docker image names
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: DockerImagesResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_docker_images
xsoar_docker_images_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_docker_image(
    base: str | None = None,
    dependencies: List[Any] | None = None,
    name: str | None = None,
    packages: List[Any] | None = None,
) -> List[types.TextContent]:
    """
    Create an image with a given list of dependencies
    
    Args:
        base (str): No description provided (optional)
        dependencies (List[Any]): No description provided (optional)
        name (str): No description provided (optional)
        packages (List[Any]): No description provided (optional)
    
    Returns:
        List[types.TextContent]: NewDockerImageResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if base is not None:
        body["base"] = base
    if dependencies is not None:
        body["dependencies"] = dependencies
    if name is not None:
        body["name"] = name
    if packages is not None:
        body["packages"] = packages

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_docker_image
xsoar_create_docker_image_schema = {
    "type": "object",
    "properties": {
        "base": {"type": "str", "description": ""},
        "dependencies": {"type": "List[Any]", "description": ""},
        "name": {"type": "str", "description": ""},
        "packages": {"type": "List[Any]", "description": ""},
    },
}

@server.call_tool()
async def xsoar_integration_upload(

) -> List[types.TextContent]:
    """
    Upload an integration to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved configuration
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/integration-conf/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_integration_upload
xsoar_integration_upload_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_reset_roi_widget(

) -> List[types.TextContent]:
    """
    Reset ROI widget
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: ROI widget has been reset
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/statistics/application/roi"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="DELETE",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_reset_roi_widget
xsoar_reset_roi_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_dashboard_old_format(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
Deprecated - use "/v2/statistics/dashboards/query
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return an array of stats results for each widget cell in dashboard.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_dashboard_old_format
xsoar_get_stats_for_dashboard_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_widget_old_format(

) -> List[types.TextContent]:
    """
    Get a given widget object statistics result.
Note: This route has many return types based on the widget type and data. Each 200X represent a 200 OK request of specific widget type and data

Deprecated - use "/v2/statistics/widgets/query
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Response differ according to the widget type
  -  Incident data type of a "table" or "list" widget returns incidentSearchResponse
     total:
       type: integer
       data:
         type: array
      items:
        "$ref": "#/definitions/Incident"
    - Indicators data type of a "table" or "list" widget returns IoCsResponse
      total:
        type: integer
      data:
        type: array
        items:
          "$ref": "#/definitions/IocObject"
    - Number widget returns a simple number
      type: integer
    - Trend widget returns a trend object
      "$ref": "#/definitions/StatsTrendsResponse"
    - Text widget returns a text object, describing the final text and the placeholders values.
      "$ref": "#/definitions/StatsTextResponse"
    - A chart data array by groups. When requesting a date, the key is the date string, according to the specified time frame. Empty groups (dates) are also returned.
      type: array
      items:
        "$ref": "#/definitions/Group"
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_widget_old_format
xsoar_get_stats_for_widget_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_complete_task_v2(

) -> List[types.TextContent]:
    """
    Complete a task with command and multiple file attachments
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_complete_task_v2
xsoar_complete_task_v2_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_submit_task_form(

) -> List[types.TextContent]:
    """
    Submit a data collection task with given answers and multiple file attachments
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/inv-playbook/task/form/submit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_submit_task_form
xsoar_submit_task_form_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_dashboard(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return an array of stats results for each widget cell in dashboard.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_dashboard
xsoar_get_stats_for_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_widget(

) -> List[types.TextContent]:
    """
    Get the statistics for the specified widget.
**Note:** This endpoint has many return types depending on the widget type and data. Each 200X represents a 200 OK request of specific widget type and data.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Response differ according to the widget type
  -  Incident data type of a "table" or "list" widget returns incidentSearchResponse
     total:
       type: integer
       data:
         type: array
      items:
        "$ref": "#/definitions/Incident"
    - Indicators data type of a "table" or "list" widget returns IoCsResponse
      total:
        type: integer
      data:
        type: array
        items:
          "$ref": "#/definitions/IocObject"
    - Number widget returns a simple number
      type: integer
    - Trend widget returns a trend object
      "$ref": "#/definitions/StatsTrendsResponse"
    - Text widget returns a text object, describing the final text and the placeholders values.
      "$ref": "#/definitions/StatsTextResponse"
    - Line chart widget or Column chart widget returns StatsResponseWithReferenceLine
      "$ref": "#/definitions/StatsResponseWithReferenceLine"
    - A chart data array by groups. When requesting a date, the key is the date string, according to the specified time frame. Empty groups (dates) are also returned.
      type: array
      items:
        "$ref": "#/definitions/Group"
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_widget
xsoar_get_stats_for_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_all_widgets(

) -> List[types.TextContent]:
    """
    Get all widgets
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return all the widgets in the system.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_all_widgets
xsoar_all_widgets_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_save_widget(
    name: str,
    widget_type: str,
    cache: Dict[str, Any] | None = None,
    accounts: Dict[str, Any] | None = None,
    cache_versn: int | None = None,
    category: str | None = None,
    commit_message: str | None = None,
    created: str | None = None,
    data_type: str | None = None,
    date_range: str | None = None,
    definition: str | None = None,
    definition_id: str | None = None,
    description: str | None = None,
    from_server_version: str | None = None,
    highlight: Dict[str, Any] | None = None,
    id: str | None = None,
    ignore_workers: bool | None = None,
    index_name: str | None = None,
    is_predefined: bool | None = None,
    item_version: str | None = None,
    locked: bool | None = None,
    modified: str | None = None,
    numeric_id: int | None = None,
    pack_id: str | None = None,
    pack_name: str | None = None,
    pack_propagation_labels: List[Any] | None = None,
    page: int | None = None,
    params: Dict[str, Any] | None = None,
    prev_name: str | None = None,
    primary_term: int | None = None,
    propagation_labels: List[Any] | None = None,
    query: str | None = None,
    remote: bool | None = None,
    search_after: List[Any] | None = None,
    search_after_elastic: List[Any] | None = None,
    search_after_map: Dict[str, Any] | None = None,
    search_after_map_order: Dict[str, Any] | None = None,
    search_before: List[Any] | None = None,
    search_before_elastic: List[Any] | None = None,
    sequence_number: int | None = None,
    should_commit: bool | None = None,
    size: int | None = None,
    size_in_bytes: int | None = None,
    skip_aggregate_accounts: bool | None = None,
    sort: List[Any] | None = None,
    sort_values: List[Any] | None = None,
    sync_hash: str | None = None,
    to_server_version: str | None = None,
    vc_should_ignore: bool | None = None,
    vc_should_keep_item_legacy_prod_machine: bool | None = None,
    version: int | None = None,
) -> List[types.TextContent]:
    """
    Add or update a given widget based on Id.
    
    Args:
        cache (Dict[str, Any]): Cache of join functions (optional)
        accounts (Dict[str, Any]): Accounts list of accounts to query the widget data from (optional)
        cache_versn (int): No description provided (optional)
        category (str): Category the widget is related to. Used to display in widget library under category or dataType if empty. (optional)
        commit_message (str): No description provided (optional)
        created (str): No description provided (optional)
        data_type (str): Data type of the widget. Describes what data does the widget query. supporting data types \"incidents\",\"messages\",\"system\",\"entries\",\"tasks\", \"audit\". (optional)
        date_range (str): No description provided (optional)
        definition (str): No description provided (optional)
        definition_id (str): No description provided (optional)
        description (str): The description of the widget's usage and data representation. (optional)
        from_server_version (str): No description provided (optional)
        highlight (Dict[str, Any]): No description provided (optional)
        id (str): No description provided (optional)
        ignore_workers (bool): Do not use workers mechanism while searching bleve (optional)
        index_name (str): No description provided (optional)
        is_predefined (bool): Is the widget a system widget. (optional)
        item_version (str): No description provided (optional)
        locked (bool): Is the widget locked for editing. (optional)
        modified (str): No description provided (optional)
        name (str): Default name of the widget. (required)
        numeric_id (int): No description provided (optional)
        pack_id (str): No description provided (optional)
        pack_name (str): No description provided (optional)
        pack_propagation_labels (List[Any]): No description provided (optional)
        page (int): 0-based page (optional)
        params (Dict[str, Any]): Additional parameters for this widget, depends on widget type and data. (optional)
        prev_name (str): The previous name of the widget. (optional)
        primary_term (int): No description provided (optional)
        propagation_labels (List[Any]): No description provided (optional)
        query (str): Query to search on the dataType. (optional)
        remote (bool): No description provided (optional)
        search_after (List[Any]): Efficient next page, pass max sort value from previous page (optional)
        search_after_elastic (List[Any]): Efficient next page, pass max ES sort value from previous page (optional)
        search_after_map (Dict[str, Any]): Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map. (optional)
        search_after_map_order (Dict[str, Any]): No description provided (optional)
        search_before (List[Any]): Efficient prev page, pass min sort value from next page (optional)
        search_before_elastic (List[Any]): Efficient prev page, pass min ES sort value from next page (optional)
        sequence_number (int): No description provided (optional)
        should_commit (bool): No description provided (optional)
        size (int): Size is limited to 1000, if not passed it defaults to 0, and no results will return (optional)
        size_in_bytes (int): No description provided (optional)
        skip_aggregate_accounts (bool): SkipAggregateAccounts flag that indicates whether to skip aggregate accounts results (optional)
        sort (List[Any]): The sort order (optional)
        sort_values (List[Any]): No description provided (optional)
        sync_hash (str): No description provided (optional)
        to_server_version (str): No description provided (optional)
        vc_should_ignore (bool): No description provided (optional)
        vc_should_keep_item_legacy_prod_machine (bool): No description provided (optional)
        version (int): No description provided (optional)
        widget_type (str): Widget type describes how does the widget should recieve the data, and display it. Supporting types: \"bar\", \"column\", \"pie\", \"list\", \"number\", \"trend\", \"text\", \"duration\", \"image\", \"line\", and \"table\". (required)
    
    Returns:
        List[types.TextContent]: The saved widget newest version.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if cache is not None:
        body["Cache"] = cache
    if accounts is not None:
        body["accounts"] = accounts
    if cache_versn is not None:
        body["cacheVersn"] = cache_versn
    if category is not None:
        body["category"] = category
    if commit_message is not None:
        body["commitMessage"] = commit_message
    if created is not None:
        body["created"] = created
    if data_type is not None:
        body["dataType"] = data_type
    if date_range is not None:
        body["dateRange"] = date_range
    if definition is not None:
        body["definition"] = definition
    if definition_id is not None:
        body["definitionId"] = definition_id
    if description is not None:
        body["description"] = description
    if from_server_version is not None:
        body["fromServerVersion"] = from_server_version
    if highlight is not None:
        body["highlight"] = highlight
    if id is not None:
        body["id"] = id
    if ignore_workers is not None:
        body["ignoreWorkers"] = ignore_workers
    if index_name is not None:
        body["indexName"] = index_name
    if is_predefined is not None:
        body["isPredefined"] = is_predefined
    if item_version is not None:
        body["itemVersion"] = item_version
    if locked is not None:
        body["locked"] = locked
    if modified is not None:
        body["modified"] = modified
    if name is not None:
        body["name"] = name
    if numeric_id is not None:
        body["numericId"] = numeric_id
    if pack_id is not None:
        body["packID"] = pack_id
    if pack_name is not None:
        body["packName"] = pack_name
    if pack_propagation_labels is not None:
        body["packPropagationLabels"] = pack_propagation_labels
    if page is not None:
        body["page"] = page
    if params is not None:
        body["params"] = params
    if prev_name is not None:
        body["prevName"] = prev_name
    if primary_term is not None:
        body["primaryTerm"] = primary_term
    if propagation_labels is not None:
        body["propagationLabels"] = propagation_labels
    if query is not None:
        body["query"] = query
    if remote is not None:
        body["remote"] = remote
    if search_after is not None:
        body["searchAfter"] = search_after
    if search_after_elastic is not None:
        body["searchAfterElastic"] = search_after_elastic
    if search_after_map is not None:
        body["searchAfterMap"] = search_after_map
    if search_after_map_order is not None:
        body["searchAfterMapOrder"] = search_after_map_order
    if search_before is not None:
        body["searchBefore"] = search_before
    if search_before_elastic is not None:
        body["searchBeforeElastic"] = search_before_elastic
    if sequence_number is not None:
        body["sequenceNumber"] = sequence_number
    if should_commit is not None:
        body["shouldCommit"] = should_commit
    if size is not None:
        body["size"] = size
    if size_in_bytes is not None:
        body["sizeInBytes"] = size_in_bytes
    if skip_aggregate_accounts is not None:
        body["skipAggregateAccounts"] = skip_aggregate_accounts
    if sort is not None:
        body["sort"] = sort
    if sort_values is not None:
        body["sortValues"] = sort_values
    if sync_hash is not None:
        body["syncHash"] = sync_hash
    if to_server_version is not None:
        body["toServerVersion"] = to_server_version
    if vc_should_ignore is not None:
        body["vcShouldIgnore"] = vc_should_ignore
    if vc_should_keep_item_legacy_prod_machine is not None:
        body["vcShouldKeepItemLegacyProdMachine"] = vc_should_keep_item_legacy_prod_machine
    if version is not None:
        body["version"] = version
    if widget_type is not None:
        body["widgetType"] = widget_type

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_widget
xsoar_save_widget_schema = {
    "type": "object",
    "properties": {
        "cache": {"type": "Dict[str, Any]", "description": "Cache of join functions"},
        "accounts": {"type": "Dict[str, Any]", "description": "Accounts list of accounts to query the widget data from"},
        "cache_versn": {"type": "int", "description": ""},
        "category": {"type": "str", "description": "Category the widget is related to. Used to display in widget library under category or dataType if empty."},
        "commit_message": {"type": "str", "description": ""},
        "created": {"type": "str", "description": ""},
        "data_type": {"type": "str", "description": "Data type of the widget. Describes what data does the widget query. supporting data types \"incidents\",\"messages\",\"system\",\"entries\",\"tasks\", \"audit\"."},
        "date_range": {"type": "str", "description": ""},
        "definition": {"type": "str", "description": ""},
        "definition_id": {"type": "str", "description": ""},
        "description": {"type": "str", "description": "The description of the widget's usage and data representation."},
        "from_server_version": {"type": "str", "description": ""},
        "highlight": {"type": "Dict[str, Any]", "description": ""},
        "id": {"type": "str", "description": ""},
        "ignore_workers": {"type": "bool", "description": "Do not use workers mechanism while searching bleve"},
        "index_name": {"type": "str", "description": ""},
        "is_predefined": {"type": "bool", "description": "Is the widget a system widget."},
        "item_version": {"type": "str", "description": ""},
        "locked": {"type": "bool", "description": "Is the widget locked for editing."},
        "modified": {"type": "str", "description": ""},
        "name": {"type": "str", "description": "Default name of the widget."},
        "numeric_id": {"type": "int", "description": ""},
        "pack_id": {"type": "str", "description": ""},
        "pack_name": {"type": "str", "description": ""},
        "pack_propagation_labels": {"type": "List[Any]", "description": ""},
        "page": {"type": "int", "description": "0-based page"},
        "params": {"type": "Dict[str, Any]", "description": "Additional parameters for this widget, depends on widget type and data."},
        "prev_name": {"type": "str", "description": "The previous name of the widget."},
        "primary_term": {"type": "int", "description": ""},
        "propagation_labels": {"type": "List[Any]", "description": ""},
        "query": {"type": "str", "description": "Query to search on the dataType."},
        "remote": {"type": "bool", "description": ""},
        "search_after": {"type": "List[Any]", "description": "Efficient next page, pass max sort value from previous page"},
        "search_after_elastic": {"type": "List[Any]", "description": "Efficient next page, pass max ES sort value from previous page"},
        "search_after_map": {"type": "Dict[str, Any]", "description": "Map accounts search after values - stores next page sort values per account. There is no need to store searchBeforeMap as [current page searchBefore] equals to [prev page searchAfter] More, there is no way to generate correct searchBefore from current page as some tenants may not appear at all. The map is relevant in proxy mode and used by tenants, each tenant extracts the searchAfter keys from the map."},
        "search_after_map_order": {"type": "Dict[str, Any]", "description": ""},
        "search_before": {"type": "List[Any]", "description": "Efficient prev page, pass min sort value from next page"},
        "search_before_elastic": {"type": "List[Any]", "description": "Efficient prev page, pass min ES sort value from next page"},
        "sequence_number": {"type": "int", "description": ""},
        "should_commit": {"type": "bool", "description": ""},
        "size": {"type": "int", "description": "Size is limited to 1000, if not passed it defaults to 0, and no results will return"},
        "size_in_bytes": {"type": "int", "description": ""},
        "skip_aggregate_accounts": {"type": "bool", "description": "SkipAggregateAccounts flag that indicates whether to skip aggregate accounts results"},
        "sort": {"type": "List[Any]", "description": "The sort order"},
        "sort_values": {"type": "List[Any]", "description": ""},
        "sync_hash": {"type": "str", "description": ""},
        "to_server_version": {"type": "str", "description": ""},
        "vc_should_ignore": {"type": "bool", "description": ""},
        "vc_should_keep_item_legacy_prod_machine": {"type": "bool", "description": ""},
        "version": {"type": "int", "description": ""},
        "widget_type": {"type": "str", "description": "Widget type describes how does the widget should recieve the data, and display it. Supporting types: \"bar\", \"column\", \"pie\", \"list\", \"number\", \"trend\", \"text\", \"duration\", \"image\", \"line\", and \"table\"."},
    },
}

@server.call_tool()
async def xsoar_import_widget(

) -> List[types.TextContent]:
    """
    Import a widget to the system, ignoring ID or version, used to import new widgets.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved widget
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_widget
xsoar_import_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Get a widget object by a given ID.
    
    Args:
        id (str): The ID of widget to get. (required)
    
    Returns:
        List[types.TextContent]: Return the widget if found.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_widget
xsoar_get_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The ID of widget to get."},
    },
}

@server.call_tool()
async def xsoar_delete_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Remove a given widget Id from the system.
    
    Args:
        id (str): Widget id to remove (returned from widget save or widgets get) (required)
    
    Returns:
        List[types.TextContent]: widget deleted
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_widget
xsoar_delete_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Widget id to remove (returned from widget save or widgets get)"},
    },
}

@server.call_tool()
async def xsoar_workers_status_handler(

) -> List[types.TextContent]:
    """
    Get workers status
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Workers status
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/workers/status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_workers_status_handler
xsoar_workers_status_handler_schema = {
    "type": "object",
    "properties": {

    },
}
