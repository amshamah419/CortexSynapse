"""
Auto-generated MCP tools for XSOAR.
Generated from OpenAPI specification: xsoar.json

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by codegen/generator.py
"""

from typing import Any, Dict, List

import httpx
from mcp.server import Server
from mcp import types

# This will be set by the server initialization
server: Server = None  # type: ignore


def set_server(s: Server) -> None:
    """Set the server instance for tool registration."""
    global server
    server = s


@server.call_tool()
async def xsoar_revoke_user_api_key(
    username: str,
) -> List[types.TextContent]:
    """
    Revoke API Key for user
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = username

    # Build URL
    url = "/apikeys/revoke/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_revoke_user_api_key
xsoar_revoke_user_api_key_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "The username which the API keys assigned to"},
    },
}

@server.call_tool()
async def xsoar_save_or_update_script(

) -> List[types.TextContent]:
    """
    Create or update a given automation.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_or_update_script
xsoar_save_or_update_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_copy_script(

) -> List[types.TextContent]:
    """
    Copy given automation
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/copy"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_copy_script
xsoar_copy_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_automation_script(

) -> List[types.TextContent]:
    """
    Delete a given automation from the system.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_automation_script
xsoar_delete_automation_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_script(

) -> List[types.TextContent]:
    """
    Import an automation to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_script
xsoar_import_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_automation_scripts(

) -> List[types.TextContent]:
    """
    Search Automation by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/automation/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_automation_scripts
xsoar_get_automation_scripts_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_classifier(

) -> List[types.TextContent]:
    """
    Import a classifier to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/classifier/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_classifier
xsoar_import_classifier_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_upload_content_packs(

) -> List[types.TextContent]:
    """
    Upload Pack to the Server. Can be used to upload a Pack for an offline scenario or a Pack that hasn't been released.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/contentpacks/installed/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_upload_content_packs
xsoar_upload_content_packs_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_dashboard(

) -> List[types.TextContent]:
    """
    Import a dashboard to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/dashboards/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_dashboard
xsoar_import_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_investigation_add_entry_handler(

) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_entry_handler
xsoar_investigation_add_entry_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_download_file(
    entryid: str,
) -> List[types.TextContent]:
    """
    Download file from Cortex XSOAR by entry ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if entryid is not None:
        path_params["entryid"] = entryid

    # Build URL
    url = "/entry/download/{entryid}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_download_file
xsoar_download_file_schema = {
    "type": "object",
    "properties": {
        "entryid": {"type": "str", "description": "Entry ID"},
    },
}

@server.call_tool()
async def xsoar_investigation_add_entries_sync(

) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/execute/sync"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_entries_sync
xsoar_investigation_add_entries_sync_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_entry_export_artifact(

) -> List[types.TextContent]:
    """
    Export an entry artifact
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/exportArtifact"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_entry_export_artifact
xsoar_entry_export_artifact_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_investigation_add_formatted_entry_handler(

) -> List[types.TextContent]:
    """
    API to create a formatted entry (table/json/text/markdown/html) in existing investigation
Body example: {"investigationId":"1234","format":"table/json/text/markdown/html","contents":"entry content…"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/formatted"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_formatted_entry_handler
xsoar_investigation_add_formatted_entry_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_update_entry_note(

) -> List[types.TextContent]:
    """
    API to mark entry as note, can be used also to remove the note
Body example: {"id":1\@1234","version":"-1","investigationId":"1234","data":"true/false"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/note"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_update_entry_note
xsoar_update_entry_note_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_update_entry_tags_op(

) -> List[types.TextContent]:
    """
    API to set entry tags
Body example: {"id":"1\@1234","version":"-1","investigationId":"1234","tags":["tag1","tag2"]"}
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/entry/tags"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_update_entry_tags_op
xsoar_update_entry_tags_op_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_save_evidence(

) -> List[types.TextContent]:
    """
    Save an evidence entity
To update evidence custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/evidence"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_evidence
xsoar_save_evidence_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_evidence_op(

) -> List[types.TextContent]:
    """
    Delete an evidence entity
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/evidence/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_evidence_op
xsoar_delete_evidence_op_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_evidence(

) -> List[types.TextContent]:
    """
    Search for an evidence entutiy by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/evidence/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_evidence
xsoar_search_evidence_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_health_handler(

) -> List[types.TextContent]:
    """
    Check if Cortex XSOAR server is available
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/health"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_health_handler
xsoar_health_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_containers(

) -> List[types.TextContent]:
    """
    Gets info on the containers - amount of running, inactive and total containers
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/health/containers"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_containers
xsoar_containers_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_incident(

) -> List[types.TextContent]:
    """
    Create or update incident according to JSON structure.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update

Use the 'createInvestigation\: true' to start the investigation process automatically. (by running a playbook based on incident type.)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incident
xsoar_create_incident_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_incidents_batch(

) -> List[types.TextContent]:
    """
    Update a batch of incidents.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batch"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incidents_batch
xsoar_create_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_export_incidents_to_csv_batch(

) -> List[types.TextContent]:
    """
    Exports an incidents batch to CSV file (returns file ID)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_incidents_to_csv_batch
xsoar_export_incidents_to_csv_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_close_incidents_batch(

) -> List[types.TextContent]:
    """
    Closes an incidents batch
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batchClose"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_close_incidents_batch
xsoar_close_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_incidents_batch(

) -> List[types.TextContent]:
    """
    Deletes an incidents batch
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_incidents_batch
xsoar_delete_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_incident_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an incident CSV file that was exported, by ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/incident/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incident_as_csv
xsoar_incident_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def xsoar_create_incident_json(

) -> List[types.TextContent]:
    """
    Create single incident from raw JSON, builds incident according to default mapping
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incident/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incident_json
xsoar_create_incident_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_incident_file_upload(
    id: str,
) -> List[types.TextContent]:
    """
    Add file attachement to an incidents
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/incident/upload/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incident_file_upload
xsoar_incident_file_upload_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Incident id to update"},
    },
}

@server.call_tool()
async def xsoar_set_tags_field(
    id: str,
) -> List[types.TextContent]:
    """
    Sets the select values of a specific tags field. The values passed to the route override the existing select
values of the field. To reset the select values pass an empty array.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/incidentfield/tags/reset/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_set_tags_field
xsoar_set_tags_field_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The machine name of the field prefixed with the type. For example indicator_tags or incident_dbotmirrortags"},
    },
}

@server.call_tool()
async def xsoar_incidents_fields_by_incident_type(
    type: str,
) -> List[types.TextContent]:
    """
    Get all incident fields associated with incident type
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if type is not None:
        path_params["type"] = type

    # Build URL
    url = "/incidentfields/associatedTypes/{type}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incidents_fields_by_incident_type
xsoar_incidents_fields_by_incident_type_schema = {
    "type": "object",
    "properties": {
        "type": {"type": "str", "description": "the name (case sensitive) of the incident type"},
    },
}

@server.call_tool()
async def xsoar_import_incident_fields(

) -> List[types.TextContent]:
    """
    Import an incident field to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidentfields/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_incident_fields
xsoar_import_incident_fields_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_incidents(

) -> List[types.TextContent]:
    """
    Search incidents across all indices. You can filter by multiple options.

**Note:** You cannot paginate results in a multi-tenant environment.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidents/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_incidents
xsoar_search_incidents_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_or_update_incident_type(

) -> List[types.TextContent]:
    """
    API to create new Incident Type
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidenttype"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_or_update_incident_type
xsoar_create_or_update_incident_type_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_incident_types_handler(

) -> List[types.TextContent]:
    """
    Import an incident type to Cortex XSOAR.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/incidenttypes/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_incident_types_handler
xsoar_import_incident_types_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_create(

) -> List[types.TextContent]:
    """
    Create an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicator/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_create
xsoar_indicators_create_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_edit(

) -> List[types.TextContent]:
    """
    Edit an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicator/edit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_edit
xsoar_indicators_edit_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicator_whitelist(

) -> List[types.TextContent]:
    """
    Whitelists or deletes an indicator entity
In order to delete an indicator and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicator/whitelist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicator_whitelist
xsoar_indicator_whitelist_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_export_indicators_to_stix_batch(

) -> List[types.TextContent]:
    """
    Exports an indicators batch to STIX file (returns file ID)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/batch/export/stix"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_indicators_to_stix_batch
xsoar_export_indicators_to_stix_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_export_indicators_to_csv_batch(

) -> List[types.TextContent]:
    """
    Exports an indicators batch to CSV file (returns file ID)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_indicators_to_csv_batch
xsoar_export_indicators_to_csv_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_indicators_batch(

) -> List[types.TextContent]:
    """
    Batch whitelist or delete indicators entities
In order to delete indicators and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_indicators_batch
xsoar_delete_indicators_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators CSV file that was exported, by ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/indicators/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_as_csv
xsoar_indicators_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def xsoar_create_feed_indicators_json(

) -> List[types.TextContent]:
    """
    Create indicators from raw JSON (similar to ingesting from a feed). Builds indicators according to the specified feed classifier,
or uses the default one if not specified.
Indicator properties (all optional except for value): **value** (string, required) | **type** (string) | **score** (number, 0-3,
default `0`, where `0` means None, `1` Good, `2` Suspicious, and `3` Bad) | **sourceBrand** (string, default `"External"`) | **sourceInstance**
(string, default `"External"`) | **reliability** (string, one of `"A - Completely reliable"`, `"B - Usually reliable"`, `"C - Fairly
reliable"`, `"D - Not usually reliable"`, `"E - Unreliable"`, `"F - Reliability cannot be judged"`) | **expirationPolicy** (string,
one of `"never"`, `"interval"`, `"indicatorType"`) | **expirationInterval** (number, in minutes)
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/feed/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_feed_indicators_json
xsoar_create_feed_indicators_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_search(

) -> List[types.TextContent]:
    """
    Search indicators by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_search
xsoar_indicators_search_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_as_stix(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators STIX V2 file that was exported, by ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/indicators/stix/v2/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_as_stix
xsoar_indicators_as_stix_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "STIX V2 file to fetch (returned from batch export to STIX call)"},
    },
}

@server.call_tool()
async def xsoar_indicators_timeline_delete(

) -> List[types.TextContent]:
    """
    Delete indicators timeline by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/timeline/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_timeline_delete
xsoar_indicators_timeline_delete_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_create_batch(

) -> List[types.TextContent]:
    """
    Create indicators from a file
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_create_batch
xsoar_indicators_create_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_or_update_whitelisted(

) -> List[types.TextContent]:
    """
    Create or update excluded indicators list
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/indicators/whitelist/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_or_update_whitelisted
xsoar_create_or_update_whitelisted_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_add_ad_hoc_task(
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Add an ad-hoc task to a running playbook
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        path_params["investigationId"] = investigation_id

    # Build URL
    url = "/inv-playbook/task/add/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_add_ad_hoc_task
xsoar_add_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_assign(

) -> List[types.TextContent]:
    """
    Assign a task to an owner
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/assign"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_assign
xsoar_task_assign_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_complete_task(

) -> List[types.TextContent]:
    """
    Complete a task with a file attachment
Deprecated - use "/v2/inv-playbook/task/complete"
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_complete_task
xsoar_complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_simple_complete_task(

) -> List[types.TextContent]:
    """
    Complete a task without a file attachment
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/complete/simple"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_simple_complete_task
xsoar_simple_complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_ad_hoc_task(
    inv_pb_task_id: str,
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Delete an ad-hoc task from a running playbook
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if inv_pb_task_id is not None:
        path_params["invPBTaskId"] = inv_pb_task_id
    if investigation_id is not None:
        path_params["investigationId"] = investigation_id

    # Build URL
    url = "/inv-playbook/task/delete/{investigationId}/{invPBTaskId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_ad_hoc_task
xsoar_delete_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "inv_pb_task_id": {"type": "str", "description": "ad-hoc task ID"},
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_set_due(

) -> List[types.TextContent]:
    """
    Set the task due date
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/due"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_set_due
xsoar_task_set_due_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_edit_ad_hoc_task(
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Edit an ad-hoc task in a running playbook
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        path_params["investigationId"] = investigation_id

    # Build URL
    url = "/inv-playbook/task/edit/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_edit_ad_hoc_task
xsoar_edit_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_add_comment(

) -> List[types.TextContent]:
    """
    Add comment to a task
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/note/add"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_add_comment
xsoar_task_add_comment_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_task_un_complete(

) -> List[types.TextContent]:
    """
    Reopen a closed task and change the status to uncomplete
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/inv-playbook/task/uncomplete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_un_complete
xsoar_task_un_complete_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_investigations(

) -> List[types.TextContent]:
    """
    This will search investigations across all indices
You can filter by multiple options
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/investigations/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_investigations
xsoar_search_investigations_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_everyone_handler(

) -> List[types.TextContent]:
    """
    Sign out all open users sessions
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/logout/everyone"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_everyone_handler
xsoar_logout_everyone_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_myself_handler(

) -> List[types.TextContent]:
    """
    Sign out all my open sessions
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/logout/myself"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_myself_handler
xsoar_logout_myself_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_myself_other_sessions_handler(

) -> List[types.TextContent]:
    """
    Sign out all my other open sessions
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/logout/myself/other"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_myself_other_sessions_handler
xsoar_logout_myself_other_sessions_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_user_sessions_handler(
    username: str,
) -> List[types.TextContent]:
    """
    Sign out all sessions of the provided username
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = username

    # Build URL
    url = "/logout/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_user_sessions_handler
xsoar_logout_user_sessions_handler_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "Username to logout"},
    },
}

@server.call_tool()
async def xsoar_override_playbook_yaml(

) -> List[types.TextContent]:
    """
    Import and override playbook in Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/playbook/save/yaml"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_override_playbook_yaml
xsoar_override_playbook_yaml_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_download_latest_report(
    id: str,
) -> List[types.TextContent]:
    """
    Get the latest report by its ID.

**Note:** To get the report, it must be a scheduled report with recipients.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/report/{id}/latest"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_download_latest_report
xsoar_download_latest_report_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_execute_report(
    request_id: str,
    id: str,
) -> List[types.TextContent]:
    """
    Execute a new report
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_id is not None:
        path_params["requestId"] = request_id
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/report/{id}/{requestId}/execute"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_execute_report
xsoar_execute_report_schema = {
    "type": "object",
    "properties": {
        "request_id": {"type": "str", "description": "the ID to register the request under"},
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_all_reports(

) -> List[types.TextContent]:
    """
    Get all of the reports
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/reports"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_all_reports
xsoar_all_reports_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_upload_report(

) -> List[types.TextContent]:
    """
    Upload a report to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/reports/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_upload_report
xsoar_upload_report_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_report_by_id(
    id: str,
) -> List[types.TextContent]:
    """
    Get a report by its ID
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/reports/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_report_by_id
xsoar_report_by_id_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_get_audits(

) -> List[types.TextContent]:
    """
    Get audits by filter
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/audits"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_audits
xsoar_get_audits_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_docker_images(

) -> List[types.TextContent]:
    """
    Get list of all available docker image names
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_docker_images
xsoar_docker_images_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_docker_image(

) -> List[types.TextContent]:
    """
    Create an image with a given list of dependencies
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_docker_image
xsoar_create_docker_image_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_integration_upload(

) -> List[types.TextContent]:
    """
    Upload an integration to Cortex XSOAR
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/settings/integration-conf/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_integration_upload
xsoar_integration_upload_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_reset_roi_widget(

) -> List[types.TextContent]:
    """
    Reset ROI widget
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/statistics/application/roi"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="DELETE",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_reset_roi_widget
xsoar_reset_roi_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_dashboard_old_format(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
Deprecated - use "/v2/statistics/dashboards/query
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_dashboard_old_format
xsoar_get_stats_for_dashboard_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_widget_old_format(

) -> List[types.TextContent]:
    """
    Get a given widget object statistics result.
Note: This route has many return types based on the widget type and data. Each 200X represent a 200 OK request of specific widget type and data

Deprecated - use "/v2/statistics/widgets/query
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_widget_old_format
xsoar_get_stats_for_widget_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_complete_task_v2(

) -> List[types.TextContent]:
    """
    Complete a task with command and multiple file attachments
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_complete_task_v2
xsoar_complete_task_v2_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_submit_task_form(

) -> List[types.TextContent]:
    """
    Submit a data collection task with given answers and multiple file attachments
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/inv-playbook/task/form/submit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_submit_task_form
xsoar_submit_task_form_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_dashboard(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_dashboard
xsoar_get_stats_for_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_widget(

) -> List[types.TextContent]:
    """
    Get the statistics for the specified widget.
**Note:** This endpoint has many return types depending on the widget type and data. Each 200X represents a 200 OK request of specific widget type and data.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/v2/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_widget
xsoar_get_stats_for_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_all_widgets(

) -> List[types.TextContent]:
    """
    Get all widgets
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_all_widgets
xsoar_all_widgets_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_save_widget(

) -> List[types.TextContent]:
    """
    Add or update a given widget based on Id.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_widget
xsoar_save_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_widget(

) -> List[types.TextContent]:
    """
    Import a widget to the system, ignoring ID or version, used to import new widgets.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/widgets/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="POST",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_widget
xsoar_import_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Get a widget object by a given ID.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_widget
xsoar_get_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The ID of widget to get."},
    },
}

@server.call_tool()
async def xsoar_delete_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Remove a given widget Id from the system.
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = id

    # Build URL
    url = "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_widget
xsoar_delete_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Widget id to remove (returned from widget save or widgets get)"},
    },
}

@server.call_tool()
async def xsoar_workers_status_handler(

) -> List[types.TextContent]:
    """
    Get workers status
    
    Args:
        Tool arguments are defined in the schema below
    
    Returns:
        List of text content with the API response
    """
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Build URL
    url = "/workers/status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request
    async with httpx.AsyncClient() as client:
        response = await client.request(
            method="GET",
            url=url,
            params=params,
            headers=headers,
            json=body if body else None,
        )
        response.raise_for_status()
        result = response.json()
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_workers_status_handler
xsoar_workers_status_handler_schema = {
    "type": "object",
    "properties": {

    },
}
