"""
Auto-generated MCP tools for XSOAR.
Generated from OpenAPI specification: xsoar.json

DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by codegen/generator.py
"""

from typing import Any, Dict, List
import os
import re

import httpx
from mcp.server import Server
from mcp import types

# This will be set by the server initialization
server: Server = None  # type: ignore


def get_api_config() -> Dict[str, str]:
    """Get API configuration from environment variables."""
    return {
        "xsiam_api_url": os.getenv("XSIAM_API_URL", "https://api-yourfqdn"),
        "xsoar_api_url": os.getenv("XSOAR_API_URL", "https://your-xsoar-instance.com"),
        "timeout": int(os.getenv("API_TIMEOUT", "30")),
        "max_retries": int(os.getenv("API_MAX_RETRIES", "3")),
        "verify_ssl": os.getenv("VERIFY_SSL", "true").lower() == "true",
    }


def get_http_client() -> httpx.AsyncClient:
    """Create a configured HTTP client with security settings."""
    config = get_api_config()
    return httpx.AsyncClient(
        timeout=config["timeout"],
        verify=config["verify_ssl"],
        limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),
    )


def sanitize_input(value: Any) -> Any:
    """Sanitize user input to prevent injection attacks."""
    if isinstance(value, str):
        # Remove potentially dangerous characters
        # Allow alphanumeric, spaces, hyphens, underscores, and common punctuation
        sanitized = re.sub(r'[^\w\s\-_.@,:/]', '', value)
        # Limit length to prevent DoS
        return sanitized[:1000]
    return value


def validate_inputs(params: Dict[str, Any]) -> None:
    """Validate input parameters."""
    for key, value in params.items():
        if key == "self":  # Skip 'self' from locals()
            continue
        if value is not None and isinstance(value, str):
            # Check for extremely long inputs
            if len(value) > 10000:
                raise ValueError(f"Input parameter '{key}' exceeds maximum length")


def sanitize_error_message(error: str) -> str:
    """Sanitize error messages to prevent information leakage."""
    # Remove sensitive information patterns
    sanitized = re.sub(r'api[_-]?key[=:]?[\s]?[\w-]+', 'API_KEY_REDACTED', error, flags=re.IGNORECASE)
    sanitized = re.sub(r'token[=:]?[\s]?[\w-]+', 'TOKEN_REDACTED', sanitized, flags=re.IGNORECASE)
    sanitized = re.sub(r'password[=:]?[\s]?[\w-]+', 'PASSWORD_REDACTED', sanitized, flags=re.IGNORECASE)
    # Limit error message length
    return sanitized[:500]



def set_server(s: Server) -> None:
    """Set the server instance for tool registration."""
    global server
    server = s


@server.call_tool()
async def xsoar_revoke_user_api_key(
    username: str,
) -> List[types.TextContent]:
    """
    Revoke API Key for user
    
    Args:
        username (str): The username which the API keys assigned to (required)
    
    Returns:
        List[types.TextContent]: 200 for success
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = sanitize_input(username)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/apikeys/revoke/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_revoke_user_api_key
xsoar_revoke_user_api_key_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "The username which the API keys assigned to"},
    },
}

@server.call_tool()
async def xsoar_save_or_update_script(

) -> List[types.TextContent]:
    """
    Create or update a given automation.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved automation.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_or_update_script
xsoar_save_or_update_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_copy_script(

) -> List[types.TextContent]:
    """
    Copy given automation
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved automation.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/copy"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_copy_script
xsoar_copy_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_automation_script(

) -> List[types.TextContent]:
    """
    Delete a given automation from the system.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: automation deleted
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_automation_script
xsoar_delete_automation_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_script(

) -> List[types.TextContent]:
    """
    Import an automation to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved automation
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_script
xsoar_import_script_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_automation_scripts(

) -> List[types.TextContent]:
    """
    Search Automation by filter
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: automationScriptResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/automation/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_automation_scripts
xsoar_get_automation_scripts_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_classifier(

) -> List[types.TextContent]:
    """
    Import a classifier to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved classifiers
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/classifier/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_classifier
xsoar_import_classifier_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_upload_content_packs(

) -> List[types.TextContent]:
    """
    Upload Pack to the Server. Can be used to upload a Pack for an offline scenario or a Pack that hasn't been released.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The pack was successfully uploaded
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/contentpacks/installed/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_upload_content_packs
xsoar_upload_content_packs_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_dashboard(

) -> List[types.TextContent]:
    """
    Import a dashboard to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved dashboard
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/dashboards/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_dashboard
xsoar_import_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_investigation_add_entry_handler(

) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_entry_handler
xsoar_investigation_add_entry_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_download_file(
    entryid: str,
) -> List[types.TextContent]:
    """
    Download file from Cortex XSOAR by entry ID
    
    Args:
        entryid (str): Entry ID (required)
    
    Returns:
        List[types.TextContent]: Return the entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if entryid is not None:
        path_params["entryid"] = sanitize_input(entryid)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/download/{entryid}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_download_file
xsoar_download_file_schema = {
    "type": "object",
    "properties": {
        "entryid": {"type": "str", "description": "Entry ID"},
    },
}

@server.call_tool()
async def xsoar_investigation_add_entries_sync(

) -> List[types.TextContent]:
    """
    API to create an entry (markdown format) in existing investigation
Body example: {"investigationId":"1234","data":"entry content…"}
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: An array of the children entries of the executed entry.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/execute/sync"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_entries_sync
xsoar_investigation_add_entries_sync_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_entry_export_artifact(

) -> List[types.TextContent]:
    """
    Export an entry artifact
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: created file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/exportArtifact"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_entry_export_artifact
xsoar_entry_export_artifact_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_investigation_add_formatted_entry_handler(

) -> List[types.TextContent]:
    """
    API to create a formatted entry (table/json/text/markdown/html) in existing investigation
Body example: {"investigationId":"1234","format":"table/json/text/markdown/html","contents":"entry content…"}
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/formatted"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_investigation_add_formatted_entry_handler
xsoar_investigation_add_formatted_entry_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_update_entry_note(

) -> List[types.TextContent]:
    """
    API to mark entry as note, can be used also to remove the note
Body example: {"id":1\@1234","version":"-1","investigationId":"1234","data":"true/false"}
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/note"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_update_entry_note
xsoar_update_entry_note_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_update_entry_tags_op(

) -> List[types.TextContent]:
    """
    API to set entry tags
Body example: {"id":"1\@1234","version":"-1","investigationId":"1234","tags":["tag1","tag2"]"}
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Entry
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/entry/tags"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_update_entry_tags_op
xsoar_update_entry_tags_op_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_save_evidence(

) -> List[types.TextContent]:
    """
    Save an evidence entity
To update evidence custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The new / updated Evidence
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/evidence"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_evidence
xsoar_save_evidence_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_evidence_op(

) -> List[types.TextContent]:
    """
    Delete an evidence entity
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Deleted evidence ID
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/evidence/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_evidence_op
xsoar_delete_evidence_op_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_evidence(

) -> List[types.TextContent]:
    """
    Search for an evidence entutiy by filter
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: EvidencesSearchResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/evidence/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_evidence
xsoar_search_evidence_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_health_handler(

) -> List[types.TextContent]:
    """
    Check if Cortex XSOAR server is available
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: OK status
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/health"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_health_handler
xsoar_health_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_containers(

) -> List[types.TextContent]:
    """
    Gets info on the containers - amount of running, inactive and total containers
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Gets info on the containers - amount of running, inactive and total containers
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/health/containers"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_containers
xsoar_containers_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_incident(

) -> List[types.TextContent]:
    """
    Create or update incident according to JSON structure.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update

Use the 'createInvestigation\: true' to start the investigation process automatically. (by running a playbook based on incident type.)
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IncidentWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incident
xsoar_create_incident_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_incidents_batch(

) -> List[types.TextContent]:
    """
    Update a batch of incidents.
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: 
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batch"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incidents_batch
xsoar_create_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_export_incidents_to_csv_batch(

) -> List[types.TextContent]:
    """
    Exports an incidents batch to CSV file (returns file ID)
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: csv file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_incidents_to_csv_batch
xsoar_export_incidents_to_csv_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_close_incidents_batch(

) -> List[types.TextContent]:
    """
    Closes an incidents batch
To update incident custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
To get the actual key name you can also go to Cortex XSOAR CLI and run /incident_add and look for the key that you would like to update
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IncidentSearchResponseWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batchClose"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_close_incidents_batch
xsoar_close_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_incidents_batch(

) -> List[types.TextContent]:
    """
    Deletes an incidents batch
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IncidentSearchResponseWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_incidents_batch
xsoar_delete_incidents_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_incident_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an incident CSV file that was exported, by ID
    
    Args:
        id (str): CSV file to fetch (returned from batch export to csv call) (required)
    
    Returns:
        List[types.TextContent]: Return Csv file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incident_as_csv
xsoar_incident_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def xsoar_create_incident_json(

) -> List[types.TextContent]:
    """
    Create single incident from raw JSON, builds incident according to default mapping
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Created
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_incident_json
xsoar_create_incident_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_incident_file_upload(
    id: str,
) -> List[types.TextContent]:
    """
    Add file attachement to an incidents
    
    Args:
        id (str): Incident id to update (required)
    
    Returns:
        List[types.TextContent]: IncidentWrapper
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incident/upload/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incident_file_upload
xsoar_incident_file_upload_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Incident id to update"},
    },
}

@server.call_tool()
async def xsoar_set_tags_field(
    id: str,
) -> List[types.TextContent]:
    """
    Sets the select values of a specific tags field. The values passed to the route override the existing select
values of the field. To reset the select values pass an empty array.
    
    Args:
        id (str): The machine name of the field prefixed with the type. For example indicator_tags or incident_dbotmirrortags (required)
    
    Returns:
        List[types.TextContent]: empty
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidentfield/tags/reset/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_set_tags_field
xsoar_set_tags_field_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The machine name of the field prefixed with the type. For example indicator_tags or incident_dbotmirrortags"},
    },
}

@server.call_tool()
async def xsoar_incidents_fields_by_incident_type(
    type: str,
) -> List[types.TextContent]:
    """
    Get all incident fields associated with incident type
    
    Args:
        type (str): the name (case sensitive) of the incident type (required)
    
    Returns:
        List[types.TextContent]: Returns a list of incident fields associated with the incident type
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if type is not None:
        path_params["type"] = sanitize_input(type)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidentfields/associatedTypes/{type}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_incidents_fields_by_incident_type
xsoar_incidents_fields_by_incident_type_schema = {
    "type": "object",
    "properties": {
        "type": {"type": "str", "description": "the name (case sensitive) of the incident type"},
    },
}

@server.call_tool()
async def xsoar_import_incident_fields(

) -> List[types.TextContent]:
    """
    Import an incident field to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved incident field
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidentfields/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_incident_fields
xsoar_import_incident_fields_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_incidents(

) -> List[types.TextContent]:
    """
    Search incidents across all indices. You can filter by multiple options.

**Note:** You cannot paginate results in a multi-tenant environment.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: incidentSearchResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidents/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_incidents
xsoar_search_incidents_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_or_update_incident_type(

) -> List[types.TextContent]:
    """
    API to create new Incident Type
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IncidentType
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidenttype"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_or_update_incident_type
xsoar_create_or_update_incident_type_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_incident_types_handler(

) -> List[types.TextContent]:
    """
    Import an incident type to Cortex XSOAR.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved incident type
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/incidenttypes/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_incident_types_handler
xsoar_import_incident_types_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_create(

) -> List[types.TextContent]:
    """
    Create an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IocObject
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicator/create"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_create
xsoar_indicators_create_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_edit(

) -> List[types.TextContent]:
    """
    Edit an indicator entity
To update indicator custom fields you should lowercase them and remove all spaces. For example: Scan IP -> scanip
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IocObject
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicator/edit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_edit
xsoar_indicators_edit_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicator_whitelist(

) -> List[types.TextContent]:
    """
    Whitelists or deletes an indicator entity
In order to delete an indicator and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: UpdateResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicator/whitelist"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicator_whitelist
xsoar_indicator_whitelist_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_export_indicators_to_stix_batch(

) -> List[types.TextContent]:
    """
    Exports an indicators batch to STIX file (returns file ID)
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: STIX file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/batch/export/stix"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_indicators_to_stix_batch
xsoar_export_indicators_to_stix_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_export_indicators_to_csv_batch(

) -> List[types.TextContent]:
    """
    Exports an indicators batch to CSV file (returns file ID)
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: csv file name
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/batch/exportToCsv"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_export_indicators_to_csv_batch
xsoar_export_indicators_to_csv_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_indicators_batch(

) -> List[types.TextContent]:
    """
    Batch whitelist or delete indicators entities
In order to delete indicators and not whitelist, set doNotWhitelist boolean field to true
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: UpdateResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/batchDelete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_indicators_batch
xsoar_delete_indicators_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_as_csv(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators CSV file that was exported, by ID
    
    Args:
        id (str): CSV file to fetch (returned from batch export to csv call) (required)
    
    Returns:
        List[types.TextContent]: Return Csv file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/csv/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_as_csv
xsoar_indicators_as_csv_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "CSV file to fetch (returned from batch export to csv call)"},
    },
}

@server.call_tool()
async def xsoar_create_feed_indicators_json(

) -> List[types.TextContent]:
    """
    Create indicators from raw JSON (similar to ingesting from a feed). Builds indicators according to the specified feed classifier,
or uses the default one if not specified.
Indicator properties (all optional except for value): **value** (string, required) | **type** (string) | **score** (number, 0-3,
default `0`, where `0` means None, `1` Good, `2` Suspicious, and `3` Bad) | **sourceBrand** (string, default `"External"`) | **sourceInstance**
(string, default `"External"`) | **reliability** (string, one of `"A - Completely reliable"`, `"B - Usually reliable"`, `"C - Fairly
reliable"`, `"D - Not usually reliable"`, `"E - Unreliable"`, `"F - Reliability cannot be judged"`) | **expirationPolicy** (string,
one of `"never"`, `"interval"`, `"indicatorType"`) | **expirationInterval** (number, in minutes)
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Indicators created
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/feed/json"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_feed_indicators_json
xsoar_create_feed_indicators_json_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_search(

) -> List[types.TextContent]:
    """
    Search indicators by filter
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: indicatorResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_search
xsoar_indicators_search_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_as_stix(
    id: str,
) -> List[types.TextContent]:
    """
    Get an indicators STIX V2 file that was exported, by ID
    
    Args:
        id (str): STIX V2 file to fetch (returned from batch export to STIX call) (required)
    
    Returns:
        List[types.TextContent]: Return STIX V2 file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/stix/v2/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_as_stix
xsoar_indicators_as_stix_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "STIX V2 file to fetch (returned from batch export to STIX call)"},
    },
}

@server.call_tool()
async def xsoar_indicators_timeline_delete(

) -> List[types.TextContent]:
    """
    Delete indicators timeline by filter
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IndicatorEditBulkResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/timeline/delete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_timeline_delete
xsoar_indicators_timeline_delete_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_indicators_create_batch(

) -> List[types.TextContent]:
    """
    Create indicators from a file
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: IocObjects
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_indicators_create_batch
xsoar_indicators_create_batch_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_or_update_whitelisted(

) -> List[types.TextContent]:
    """
    Create or update excluded indicators list
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: WhitelistedIndicator
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/indicators/whitelist/update"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_or_update_whitelisted
xsoar_create_or_update_whitelisted_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_add_ad_hoc_task(
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Add an ad-hoc task to a running playbook
    
    Args:
        investigation_id (str): investigation ID (required)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        path_params["investigationId"] = sanitize_input(investigation_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/add/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_add_ad_hoc_task
xsoar_add_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_assign(

) -> List[types.TextContent]:
    """
    Assign a task to an owner
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/assign"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_assign
xsoar_task_assign_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_complete_task(

) -> List[types.TextContent]:
    """
    Complete a task with a file attachment
Deprecated - use "/v2/inv-playbook/task/complete"
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_complete_task
xsoar_complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_simple_complete_task(

) -> List[types.TextContent]:
    """
    Complete a task without a file attachment
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/complete/simple"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_simple_complete_task
xsoar_simple_complete_task_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_delete_ad_hoc_task(
    inv_pb_task_id: str,
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Delete an ad-hoc task from a running playbook
    
    Args:
        inv_pb_task_id (str): ad-hoc task ID (required)
        investigation_id (str): investigation ID (required)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if inv_pb_task_id is not None:
        path_params["invPBTaskId"] = sanitize_input(inv_pb_task_id)
    if investigation_id is not None:
        path_params["investigationId"] = sanitize_input(investigation_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/delete/{investigationId}/{invPBTaskId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_ad_hoc_task
xsoar_delete_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "inv_pb_task_id": {"type": "str", "description": "ad-hoc task ID"},
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_set_due(

) -> List[types.TextContent]:
    """
    Set the task due date
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/due"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_set_due
xsoar_task_set_due_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_edit_ad_hoc_task(
    investigation_id: str,
) -> List[types.TextContent]:
    """
    Edit an ad-hoc task in a running playbook
    
    Args:
        investigation_id (str): investigation ID (required)
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if investigation_id is not None:
        path_params["investigationId"] = sanitize_input(investigation_id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/edit/{investigationId}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_edit_ad_hoc_task
xsoar_edit_ad_hoc_task_schema = {
    "type": "object",
    "properties": {
        "investigation_id": {"type": "str", "description": "investigation ID"},
    },
}

@server.call_tool()
async def xsoar_task_add_comment(

) -> List[types.TextContent]:
    """
    Add comment to a task
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/note/add"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_add_comment
xsoar_task_add_comment_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_task_un_complete(

) -> List[types.TextContent]:
    """
    Reopen a closed task and change the status to uncomplete
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/inv-playbook/task/uncomplete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_task_un_complete
xsoar_task_un_complete_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_search_investigations(

) -> List[types.TextContent]:
    """
    This will search investigations across all indices
You can filter by multiple options
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: investigationSearchResponse
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/investigations/search"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_search_investigations
xsoar_search_investigations_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_everyone_handler(

) -> List[types.TextContent]:
    """
    Sign out all open users sessions
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/everyone"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_everyone_handler
xsoar_logout_everyone_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_myself_handler(

) -> List[types.TextContent]:
    """
    Sign out all my open sessions
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/myself"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_myself_handler
xsoar_logout_myself_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_myself_other_sessions_handler(

) -> List[types.TextContent]:
    """
    Sign out all my other open sessions
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/myself/other"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_myself_other_sessions_handler
xsoar_logout_myself_other_sessions_handler_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_logout_user_sessions_handler(
    username: str,
) -> List[types.TextContent]:
    """
    Sign out all sessions of the provided username
    
    Args:
        username (str): Username to logout (required)
    
    Returns:
        List[types.TextContent]: no content
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if username is not None:
        path_params["username"] = sanitize_input(username)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/logout/user/{username}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_logout_user_sessions_handler
xsoar_logout_user_sessions_handler_schema = {
    "type": "object",
    "properties": {
        "username": {"type": "str", "description": "Username to logout"},
    },
}

@server.call_tool()
async def xsoar_override_playbook_yaml(

) -> List[types.TextContent]:
    """
    Import and override playbook in Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved playbook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/playbook/save/yaml"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_override_playbook_yaml
xsoar_override_playbook_yaml_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_download_latest_report(
    id: str,
) -> List[types.TextContent]:
    """
    Get the latest report by its ID.

**Note:** To get the report, it must be a scheduled report with recipients.
    
    Args:
        id (str): the ID of the report to get (required)
    
    Returns:
        List[types.TextContent]: Return a report file
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/report/{id}/latest"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_download_latest_report
xsoar_download_latest_report_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_execute_report(
    request_id: str,
    id: str,
) -> List[types.TextContent]:
    """
    Execute a new report
    
    Args:
        request_id (str): the ID to register the request under (required)
        id (str): the ID of the report to get (required)
    
    Returns:
        List[types.TextContent]: Request registered
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if request_id is not None:
        path_params["requestId"] = sanitize_input(request_id)
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/report/{id}/{requestId}/execute"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_execute_report
xsoar_execute_report_schema = {
    "type": "object",
    "properties": {
        "request_id": {"type": "str", "description": "the ID to register the request under"},
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_all_reports(

) -> List[types.TextContent]:
    """
    Get all of the reports
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return array of reports
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/reports"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_all_reports
xsoar_all_reports_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_upload_report(

) -> List[types.TextContent]:
    """
    Upload a report to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: A list of all the reports in the instance
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/reports/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_upload_report
xsoar_upload_report_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_report_by_id(
    id: str,
) -> List[types.TextContent]:
    """
    Get a report by its ID
    
    Args:
        id (str): the ID of the report to get (required)
    
    Returns:
        List[types.TextContent]: Return a report
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/reports/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_report_by_id
xsoar_report_by_id_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "the ID of the report to get"},
    },
}

@server.call_tool()
async def xsoar_get_audits(

) -> List[types.TextContent]:
    """
    Get audits by filter
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: auditResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/audits"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_audits
xsoar_get_audits_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_docker_images(

) -> List[types.TextContent]:
    """
    Get list of all available docker image names
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: DockerImagesResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_docker_images
xsoar_docker_images_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_create_docker_image(

) -> List[types.TextContent]:
    """
    Create an image with a given list of dependencies
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: NewDockerImageResult
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/docker-images"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_create_docker_image
xsoar_create_docker_image_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_integration_upload(

) -> List[types.TextContent]:
    """
    Upload an integration to Cortex XSOAR
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved configuration
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/settings/integration-conf/upload"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_integration_upload
xsoar_integration_upload_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_reset_roi_widget(

) -> List[types.TextContent]:
    """
    Reset ROI widget
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: ROI widget has been reset
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/statistics/application/roi"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="DELETE",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_reset_roi_widget
xsoar_reset_roi_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_dashboard_old_format(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
Deprecated - use "/v2/statistics/dashboards/query
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return an array of stats results for each widget cell in dashboard.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_dashboard_old_format
xsoar_get_stats_for_dashboard_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_widget_old_format(

) -> List[types.TextContent]:
    """
    Get a given widget object statistics result.
Note: This route has many return types based on the widget type and data. Each 200X represent a 200 OK request of specific widget type and data

Deprecated - use "/v2/statistics/widgets/query
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Response differ according to the widget type
  -  Incident data type of a "table" or "list" widget returns incidentSearchResponse
     total:
       type: integer
       data:
         type: array
      items:
        "$ref": "#/definitions/Incident"
    - Indicators data type of a "table" or "list" widget returns IoCsResponse
      total:
        type: integer
      data:
        type: array
        items:
          "$ref": "#/definitions/IocObject"
    - Number widget returns a simple number
      type: integer
    - Trend widget returns a trend object
      "$ref": "#/definitions/StatsTrendsResponse"
    - Text widget returns a text object, describing the final text and the placeholders values.
      "$ref": "#/definitions/StatsTextResponse"
    - A chart data array by groups. When requesting a date, the key is the date string, according to the specified time frame. Empty groups (dates) are also returned.
      type: array
      items:
        "$ref": "#/definitions/Group"
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_widget_old_format
xsoar_get_stats_for_widget_old_format_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_complete_task_v2(

) -> List[types.TextContent]:
    """
    Complete a task with command and multiple file attachments
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/inv-playbook/task/complete"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_complete_task_v2
xsoar_complete_task_v2_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_submit_task_form(

) -> List[types.TextContent]:
    """
    Submit a data collection task with given answers and multiple file attachments
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: InvestigationPlaybook
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/inv-playbook/task/form/submit"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_submit_task_form
xsoar_submit_task_form_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_dashboard(

) -> List[types.TextContent]:
    """
    Get a given dashboard statistics result.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return an array of stats results for each widget cell in dashboard.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/statistics/dashboards/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_dashboard
xsoar_get_stats_for_dashboard_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_stats_for_widget(

) -> List[types.TextContent]:
    """
    Get the statistics for the specified widget.
**Note:** This endpoint has many return types depending on the widget type and data. Each 200X represents a 200 OK request of specific widget type and data.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Response differ according to the widget type
  -  Incident data type of a "table" or "list" widget returns incidentSearchResponse
     total:
       type: integer
       data:
         type: array
      items:
        "$ref": "#/definitions/Incident"
    - Indicators data type of a "table" or "list" widget returns IoCsResponse
      total:
        type: integer
      data:
        type: array
        items:
          "$ref": "#/definitions/IocObject"
    - Number widget returns a simple number
      type: integer
    - Trend widget returns a trend object
      "$ref": "#/definitions/StatsTrendsResponse"
    - Text widget returns a text object, describing the final text and the placeholders values.
      "$ref": "#/definitions/StatsTextResponse"
    - Line chart widget or Column chart widget returns StatsResponseWithReferenceLine
      "$ref": "#/definitions/StatsResponseWithReferenceLine"
    - A chart data array by groups. When requesting a date, the key is the date string, according to the specified time frame. Empty groups (dates) are also returned.
      type: array
      items:
        "$ref": "#/definitions/Group"
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/v2/statistics/widgets/query"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_stats_for_widget
xsoar_get_stats_for_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_all_widgets(

) -> List[types.TextContent]:
    """
    Get all widgets
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Return all the widgets in the system.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_all_widgets
xsoar_all_widgets_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_save_widget(

) -> List[types.TextContent]:
    """
    Add or update a given widget based on Id.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved widget newest version.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_save_widget
xsoar_save_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_import_widget(

) -> List[types.TextContent]:
    """
    Import a widget to the system, ignoring ID or version, used to import new widgets.
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: The saved widget
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets/import"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="POST",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_import_widget
xsoar_import_widget_schema = {
    "type": "object",
    "properties": {

    },
}

@server.call_tool()
async def xsoar_get_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Get a widget object by a given ID.
    
    Args:
        id (str): The ID of widget to get. (required)
    
    Returns:
        List[types.TextContent]: Return the widget if found.
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_get_widget
xsoar_get_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "The ID of widget to get."},
    },
}

@server.call_tool()
async def xsoar_delete_widget(
    id: str,
) -> List[types.TextContent]:
    """
    Remove a given widget Id from the system.
    
    Args:
        id (str): Widget id to remove (returned from widget save or widgets get) (required)
    
    Returns:
        List[types.TextContent]: widget deleted
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    
    if id is not None:
        path_params["id"] = sanitize_input(id)

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/widgets/{id}"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_delete_widget
xsoar_delete_widget_schema = {
    "type": "object",
    "properties": {
        "id": {"type": "str", "description": "Widget id to remove (returned from widget save or widgets get)"},
    },
}

@server.call_tool()
async def xsoar_workers_status_handler(

) -> List[types.TextContent]:
    """
    Get workers status
    
    Args:
        No parameters required
    
    Returns:
        List[types.TextContent]: Workers status
    """
    # Input validation
    validate_inputs(locals())
    
    # Build request parameters
    params = {}
    body = {}
    path_params = {}
    headers = {}
    

    # Get base URL from environment
    base_url = get_api_config().get("xsoar_api_url", "")
    url = base_url + "/workers/status"
    for key, value in path_params.items():
        url = url.replace("{" + key + "}", str(value))
    
    # Make the API request with security controls
    try:
        async with get_http_client() as client:
            response = await client.request(
                method="GET",
                url=url,
                params=params,
                headers=headers,
                json=body if body else None,
            )
            response.raise_for_status()
            result = response.json()
    except httpx.HTTPStatusError as e:
        # Sanitize error messages to prevent information leakage
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(str(e)),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=sanitize_error_message(f"Request failed: {str(e)}"),
            )
        ]
    
    return [
        types.TextContent(
            type="text",
            text=f"{result}",
        )
    ]


# Schema for xsoar_workers_status_handler
xsoar_workers_status_handler_schema = {
    "type": "object",
    "properties": {

    },
}
